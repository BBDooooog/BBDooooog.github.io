<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F11%2F24%2F1%2F</url>
    <content type="text"><![CDATA[${menu.text} $(function(){ FavorMenusPro.content_width = parseInt($("#favorOperations").width()); var li_width = 0; var div_index_array = new Array(); var IEFlag = document.all ? true : false; var IE_V_6 = false; var IE_V_7 = false; if(IEFlag){ IE_V_6 = navigator.appVersion.match(/6./i)=="6." ? true : false; IE_V_7 = navigator.appVersion.match(/7./i)=="7." ? true : false; } //alert(IEFlag+"|"+IE_V_6+"|"+IE_V_7); if(IE_V_6||IE_V_7){ for(var i=1;i=+.content_width){ div_index_array.push(i-1); li_width = 0; i--; } } }else{ for(var i=1;i=FavorMenusPro.content_width){ div_index_array.push(i); li_width = 0; } } } if(div_index_array.length]]></content>
  </entry>
  <entry>
    <title><![CDATA[mybatis-generator]]></title>
    <url>%2F2018%2F11%2F23%2Fmybatis-generator%2F</url>
    <content type="text"><![CDATA[abstract 添加依赖1234567891011&lt;!-- mybatis generator 自动生成代码插件 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; 编辑配置文件在&lt;configurationFile&gt;指向的位置添加generatorConfig.xml文件当前目录123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt; &lt;classPathEntry location="D:\bbgog\bbdog-maven\maven-repository\org\mariadb\jdbc\mariadb-java-client\2.3.0\mariadb-java-client-2.3.0.jar"/&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass="org.mariadb.jdbc.Driver" connectionURL="jdbc:mariadb://localhost:3306/test" userId="root" password="123456"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置--&gt; &lt;javaModelGenerator targetPackage="com.demo.entity" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件的包名和位置--&gt; &lt;sqlMapGenerator targetPackage="mapping" targetProject="src/main/resources"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成mapper的包名和位置--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.demo.mapper" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt; &lt;table tableName="user" domainObjectName="User" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 启动generator在指定位置新建需求表123456CREATE TABLE USER ( user_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, user_name VARCHAR ( 255 ) NOT NULL, PASSWORD VARCHAR ( 255 ) NOT NULL, phone VARCHAR ( 255 ) NOT NULL) ENGINE = INNODB AUTO_INCREMENT = 1000 DEFAULT CHARSET = utf8; 双击启动generator 生成后项目目录 生成对应POJO类 生成对应mapper 生成对应mapper.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.demo.mapper.UserMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.demo.entity.User" &gt; &lt;id column="user_id" property="userId" jdbcType="INTEGER" /&gt; &lt;result column="user_name" property="userName" jdbcType="VARCHAR" /&gt; &lt;result column="password" property="password" jdbcType="VARCHAR" /&gt; &lt;result column="phone" property="phone" jdbcType="VARCHAR" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; user_id, user_name, password, phone &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from user where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from user where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.demo.entity.User" &gt; insert into user (user_id, user_name, password, phone) values (#&#123;userId,jdbcType=INTEGER&#125;, #&#123;userName,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, #&#123;phone,jdbcType=VARCHAR&#125;) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.demo.entity.User" &gt; insert into user &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="userId != null" &gt; user_id, &lt;/if&gt; &lt;if test="userName != null" &gt; user_name, &lt;/if&gt; &lt;if test="password != null" &gt; password, &lt;/if&gt; &lt;if test="phone != null" &gt; phone, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="userId != null" &gt; #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="userName != null" &gt; #&#123;userName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null" &gt; #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.demo.entity.User" &gt; update user &lt;set &gt; &lt;if test="userName != null" &gt; user_name = #&#123;userName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; password = #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null" &gt; phone = #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/set&gt; where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.demo.entity.User" &gt; update user set user_name = #&#123;userName,jdbcType=VARCHAR&#125;, password = #&#123;password,jdbcType=VARCHAR&#125;, phone = #&#123;phone,jdbcType=VARCHAR&#125; where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/update&gt;&lt;/mapper&gt;]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>generator</tag>
        <tag>逆向生成文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4j补充]]></title>
    <url>%2F2018%2F11%2F23%2FLog4j%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[Log4j补充 LoggerConfig LevelEvent Level和LoggerConfig Level对照表 Event Level LoggerConfig Level LoggerConfig Level LoggerConfig Level LoggerConfig Level LoggerConfig Level LoggerConfig Level LoggerConfig Level Event Level TRACE DEBUG INFO WARN ERROR FATAL OFF ALL YES YES YES YES YES YES NO TRACE YES NO NO NO NO NO NO DEBUG YES YES NO NO NO NO NO INFO YES YES YES NO NO NO NO WARN YES YES YES YES NO NO NO ERROR YES YES YES YES YES NO NO FATAL YES YES YES YES YES YES NO OFF NO NO NO NO NO NO NO 感谢大佬翻译了APILog4j输出格式控制–log4j的PatternLayout参数含义以及详细配置 官方API 没把格式化看懂，但是意外发现了一个markdown编辑神器，可以把excel表格转为Markdown表格。详见文章【利器】 参数 说明 例子 %c 列出logger名字空间的全称，如果加上{&lt;层数&gt;}表示列出从最内层算起的指定层数的名字空间 log4j配置文件参数举例 输出显示媒介 假设当前logger名字空间是”a.b.c” %c a.b.c %c{2} b.c %20c （若名字空间长度小于20，则左边用空格填充） %-20c （若名字空间长度小于20，则右边用空格填充） %.30c （若名字空间长度超过30，截去多余字符） %20.30c （若名字空间长度小于20，则左边用空格填充；若名字空间长度超过30，截去多余字符） %-20.30c （若名字空间长度小于20，则右边用空格填充；若名字空间长度超过30，截去多余字符） %C 列出调用logger的类的全名（包含包路径） 假设当前类是”org.apache.xyz.SomeClass” %C org.apache.xyz.SomeClass %C{1} SomeClass %d 显示日志记录时间，{&lt;日期格式&gt;}使用ISO8601定义的日期格式 %d{yyyy/MM/dd HH:mm:ss,SSS} 2005/10/12 22:23:30,117 %d{ABSOLUTE} 22:23:30,117 %d{DATE} 12 Oct 2005 22:23:30,117 %d{ISO8601} 2005-10-12 22:23:30,117 %F 显示调用logger的源文件名 %F MyClass.java %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数 %l MyClass.main(MyClass.java:129) %L 显示调用logger的代码行 %L 129 %m 显示输出消息 %m This is a message for debug. %M 显示调用logger的方法名 %M main %n 当前平台下的换行符 %n Windows平台下表示rn UNIX平台下表示n %p 显示该条日志的优先级 %p INFO %r 显示从程序启动时到记录该条日志时已经经过的毫秒数 %r 1215 %t 输出产生该日志事件的线程名 %t MyClass %x 按NDC（Nested Diagnostic Context，线程堆栈）顺序输出日志 假设某程序调用顺序是MyApp调用com.foo.Bar %c %x - %m%n MyApp - Call com.foo.Bar. com.foo.Bar - Log in Bar MyApp - Return to MyApp. %X 按MDC（Mapped Diagnostic Context，线程映射表）输出日志。通常用于多个客户端连接同一台服务器，方便服务器区分是那个客户端访问留下来的日志。 %X{5} （记录代号为5的客户端的日志） %% 显示一个百分号 %% %]]></content>
      <categories>
        <category>Log4j</category>
      </categories>
      <tags>
        <tag>log4j</tag>
        <tag>补充</tag>
        <tag>log4j格式化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利器]]></title>
    <url>%2F2018%2F11%2F23%2F%E5%88%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[这是你的金斧子吗？这是你的银斧子吗？ 编辑器markdownExcel表格转Markdown表格官网高大上，功能很强大，未深喑其中功能但觉得安装包不小。Typora官网]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4j]]></title>
    <url>%2F2018%2F11%2F23%2FLog4j%2F</url>
    <content type="text"><![CDATA[abstract 添加依赖在pom.xml文件中添加如下依赖12345678910111213141516171819&lt;!-- spring boot start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!-- 排除自带的logback依赖 --&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- springboot-log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt; &lt;version&gt;1.3.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 编辑配置文件rootloggerrootlogger主要定义log4j支持的日志级别及输出目的地，其语法为：1log4j.rootLogger = [ level ] , appenderName, appenderName, … level 是日志记录的优先级，分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别。 appenderName指定日志信息输出到哪个地方，可同时指定多个输出目的地。 例如:1log4j.rootLogger=info, stdout appenderappender附加器主要定义日志信息输出在什么位置，主要语法为： 123456789101112131415161718192021log4j.appender.appenderName = classInfolog4j.appender.appenderName.option1 = value1 …log4j.appender.appenderName.optionN = valueN``` appenderName与rootlogger中的appenderName对应 appender有以下几种：+ org.apache.log4j.ConsoleAppender（控制台）+ org.apache.log4j.FileAppender（文件）+ org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）+ org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）+ org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）### 输出到控制台(org.apache.log4j.ConsoleAppender)```ymllog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %5p %c&#123;1&#125;:%L - %m%n ### Layout 负责格式化Appender的输出，其语法为Layout 负责格式化Appender的输出，其中，Log4j提供的layout有以下几种： org.apache.log4j.HTMLLayout（以HTML表格形式布局）， org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串） org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） 例如：12log4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %5p %c&#123;1&#125;:%L - %m%n ConversionPattern中的格式化参数详见Log4j补充]]></content>
      <categories>
        <category>Log4j</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>Log4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web.xml]]></title>
    <url>%2F2018%2F10%2F25%2Fweb-xml%2F</url>
    <content type="text"><![CDATA[什么是web.xml?在一个web项目中，往往需要一些初始化配置信息，如Welcome页面、servlet、servlet-mapping、filter、listener、启动加载级别等。web.xml文件就是用来初始化这些配置信息。但不是所有的web项目都需要web.xml文件，如果配置不是很负责，可以将他们放到Application中。 ##web.xmlweb.xml也遵循Schema配置的规则，以&lt;web-app&gt;为根标签。文件配置信息为: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; #指定Web应用的大图标和小图标 &lt;icon&gt; &lt;small-icon&gt;/images/app_small.gif&lt;/small-icon&gt; &lt;large-icon&gt;/images/app_large.gif&lt;/large-icon&gt; &lt;/icon&gt; #Web应用的名称 &lt;display-name&gt;Tomcat Example&lt;/display-name&gt; #给出于此相关的说明性文本 &lt;disciption&gt;Tomcat Example servlets and JSP pages.&lt;/disciption&gt; &lt;context-param&gt; &lt;param-name&gt;ContextParameter&lt;/para-name&gt; &lt;param-value&gt;test&lt;/param-value&gt; &lt;description&gt;It is a test parameter.&lt;/description&gt; &lt;/context-param&gt; &lt;!-- 过滤器配置 --&gt; &lt;filter&gt; &lt;filter-name&gt;setCharacterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;com.myTest.setCharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;setCharacterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 监听器 --&gt; &lt;listener&gt; &lt;listerner-class&gt;com.listener.SessionListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;servlet名称&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet类全路径&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;参数名&lt;/param-name&gt; &lt;param-value&gt;参数值&lt;/param-value&gt; &lt;/init-param&gt; &lt;run-as&gt; &lt;description&gt;匿名访问的角色&lt;/description&gt; &lt;role-name&gt;tomcat&lt;/role-name&gt; &lt;/run-as&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;servelet名称&lt;/servlet-name&gt; &lt;url-pattern&gt;映射路径&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- session超时时间（单位：分钟）--&gt; &lt;session-config&gt; &lt;session-timeout&gt;120&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;!-- mime --&gt; &lt;mime-mapping&gt; &lt;extension&gt;htm&lt;/extension&gt; &lt;mime-type&gt;text/html&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;!-- 欢迎页 --&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 错误代码跳转页 --&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/NotFound.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.NullException&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;jsp-config&gt; &lt;taglib&gt; &lt;taglib-uri&gt;Taglib&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/tlds/MyTaglib.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;jsp-property-group&gt; &lt;description&gt;Special property group for JSP Configuration JSP example.&lt;/description&gt; &lt;display-name&gt;JSPConfiguration&lt;/display-name&gt; &lt;url-pattern&gt;/jsp/* &lt;/url-pattern&gt; &lt;el-ignored&gt;true&lt;/el-ignored&gt; &lt;page-encoding&gt;GB2312&lt;/page-encoding&gt; &lt;scripting-invalid&gt;true&lt;/scripting-invalid&gt; &lt;include-prelude&gt;/include/prelude.jspf&lt;/include-prelude&gt; &lt;include-coda&gt;/include/coda.jspf&lt;/include-coda&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>web.xml</category>
      </categories>
      <tags>
        <tag>web.xml</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Red-Black Tree]]></title>
    <url>%2F2018%2F10%2F23%2FRed-Black-Tree%2F</url>
    <content type="text"><![CDATA[你必须非常努力,才能看起来毫不费力 ———TreeMap 查找查找几乎是现在每时每刻都在用的东西，查找的速度决定了发展的速度。常用查找如： 顺序查找 二分查找 插值查找 斐波那契查找 树查找 分块查找 哈希查找 二叉树查找算法思想：为了查找的方便和快捷，先把待查找的数据生成一棵二叉排序树，利用排序树进行查找 二叉排序树有几个性值： 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树。 二叉查找树性质：对二叉查找树进行中序遍历(左根右)，即可得到有序的数列。 时间复杂度分析： 最优的情况是一个我们构建出一个完全二叉树,时间复杂度与二分查找相同,即树的高度，为O(logn)。 最坏情况是构造出一个单支树,时间复杂度为O(n); 所以，想享受O(logn)的时间复杂度的代价就是，花大功夫构造出一个便于查找的二叉树树。 2-3查找树2-3节点有下列三种可能： 节点为空节点 节点为2节点，2节点中有一个key,有两个2-3节点。左子所有key比2节点的key都小，右子所有key比2节点的key都大。 节点为3节点，3节点中有两个key,有三个2-3节点，左子所有key比3节点小的key都小，中子所有key都介于3节点两个key之间,右子所有key比3节点大的key都大。 2-3查找树特性： 在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。 时间复杂度分析： 最坏情况是所有节点都是2节点，回归二叉树，而且二叉树最优情况完全二叉树，时间复杂度为O(log2n); 最好情况是所有节点都是3节点，时间复杂度就是O(log3n),约等于O(0.631log2n)。 红黑树红黑树是2-3查找树最简单的一种实现。红黑树特性： 每个节点或者是黑色，或者是红色。根节点是黑色。 每个叶子节点（为空的）都是黑色。 红色节点的子节点都是黑色 一个节点到每个子孙节点（叶子节点），经过的黑色节点数都是相同的。 为什么说红黑树是2-3树的简单实现呢。把每个节点看作是2节点。规定红色节点与左子的链接为红色链接。红色链接连接的两个节点看做是一个3节点,就转化成了2-3查找树 TreeMap源码解析（基于jdk1.7）TreeMap是红黑树的实现,首先来看一下TreeMap的Entry 123456K key;V value;Entry&lt;K,V&gt; left = null;Entry&lt;K,V&gt; right = null;Entry&lt;K,V&gt; parent;boolean color = BLACK; 与树的Entry相比多了一个颜色标志位 color。 TreeMap的常用操作 get() put() remove() get()因为TreeMap是已经平衡过的树（因为每次对树的解构进行改动的时候都会重新调整一遍树的机构使其每次使用时都保持最佳状态，映照开头第一句话），所以get()操作就是对排序树的遍历查找，与根节点比较，从而判断下一步走向。如此循环，直至找到对应Entry，或者没有找到而结束。 get()方法调用getEntry方法实现遍历查找12345678910111213141516171819final Entry&lt;K,V&gt; getEntry(Object key) &#123; // Offload comparator-based version for sake of performance if (comparator != null) return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; &#125; return null; &#125; Offload comparator-based version for sake of performance(为了性能，卸载基于比较器的版本) put()put()方法则是先进行一遍get操作，通过K比较，将新Entry放在合适位置，如果是普通二叉树，插入操作到这里就结束了，但是这是红黑树。需要对数的结构进行负责。所以在找到合适位置，插入新Entry之后又对红黑树进行了整体调整。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; if (t == null) &#123; compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; else &#123; if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); rotateLeft(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); rotateRight(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); &#125; &#125; &#125; root.color = BLACK; &#125; remove()remove()方法同样是需要先调用getEntry找到要删除的元素，然后调用deleteEntry删除该元素，删除元素之后同样需要再次对红黑树进行解构调整。 123456789public V remove(Object key) &#123; Entry&lt;K,V&gt; p = getEntry(key); if (p == null) return null; V oldValue = p.value; deleteEntry(p); return oldValue; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; size--; // If strictly internal, copy successor's element to p and then make p // point to successor. if (p.left != null &amp;&amp; p.right != null) &#123; Entry&lt;K,V&gt; s = successor(p); p.key = s.key; p.value = s.value; p = s; &#125; // p has 2 children // Start fixup at replacement node, if it exists. Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123; // Link replacement to parent replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; // Null out links so they are OK to use by fixAfterDeletion. p.left = p.right = p.parent = null; // Fix replacement if (p.color == BLACK) fixAfterDeletion(replacement); &#125; else if (p.parent == null) &#123; // return if we are the only node. root = null; &#125; else &#123; // No children. Use self as phantom replacement and unlink. if (p.color == BLACK) fixAfterDeletion(p); if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; if (x == leftOf(parentOf(x))) &#123; Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateLeft(parentOf(x)); sib = rightOf(parentOf(x)); &#125; if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); setColor(sib, RED); rotateRight(sib); sib = rightOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(rightOf(sib), BLACK); rotateLeft(parentOf(x)); x = root; &#125; &#125; else &#123; // symmetric Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateRight(parentOf(x)); sib = leftOf(parentOf(x)); &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); setColor(sib, RED); rotateLeft(sib); sib = leftOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(leftOf(sib), BLACK); rotateRight(parentOf(x)); x = root; &#125; &#125; &#125; setColor(x, BLACK); &#125; 总结一下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>查找</tag>
        <tag>二叉树</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuffer和StringBuilder]]></title>
    <url>%2F2018%2F10%2F16%2FString-StringBuffer-StringBuilder%2F</url>
    <content type="text"><![CDATA[整理一下近期学习的String、StringBuffer和StringBuilder之间的区别 执行速度：String &lt; StringBuffer &lt; Stringbuilder String与StringBuffer和StringBuilder之间的区别 String:字符串常量 StringBuffer:字符串变量 StringBuilder:字符串变量 我们知道String是常量，常量是不可以修改的。123456789101112131415public static void main(String[] args)&#123; String str = "123"; change(str); System.out.println(str);&#125;public static void change(String s)&#123; System.out.println(s); s = s + "abc"; system.out.println(s);&#125;/*console:123123abc123*/ 可以看到change方法并没有起到效果。 调用change方法时，str和s都指向”123” 当执行s = s + &quot;abc&quot;时s指向了”123abc” ，str还是指向”123” 123String s = "123";s = s + "abc";System.out.print(s); //result : 123abc 既然是常量，那为什么这里还可以对常量进行操作呢？JVM会创建一个新的字符串常量，原来的字符串常量成为垃圾被GC回收掉。StringBuffer和StringBuilder是字符串变量，对他们的操作是在原对象上进行的操作。 所以执行速度：String &lt; StringBuffer &lt; Stringbuilder 特例12String Str = "123" + "abc" + "123abc";StringBuffer Strb = new StringBuffer("123").append("abc").append("123abc"); 上面两个字符串生成的速度并不像预期的那样，StringBuffer 快于 String。为什么？因为JVM在创建字符串常量时123String Str = "123" + "abc" + "123abc";//就等于String Str = "123abc123abc"; 所以直接被创建出来，速度很快。但是如果分步执行，就会按照JVM对常规字符串常量的操作，创建新常量，回收旧常量的方式进行操作。]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>StringBuffer</tag>
        <tag>StringBuilder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven]]></title>
    <url>%2F2018%2F10%2F12%2Fmaven%2F</url>
    <content type="text"><![CDATA[abstract pom.XMLmaven坐标Maven坐标元素包括 groupId、artifactId、version、packaging、classifier.groupId：定义当前Maven项目隶属的实际项目。artifactId: 定义实际项目中的一个Maven模块。version: 定义Maven项目当前所处的版本。packaging: 定义Maven项目的打包方式。classifier: 帮助定义构件输出的一些附属构件。 传递性依赖首先我们要了解什么叫直接依赖，A依赖于B，B就是A的直接依赖。A-&gt;B，B-&gt;(C,D)。C、D都是A的传递性依赖。 我们在使用A的时候只需要指出他的直接依赖，maven会自动帮我们解析出我们所需要的间接依赖，而不会引入多余的包。 如果间接依赖引用了同一个项目，但版本不同时，maven解析有两个优先原则： 深度策略。A-&gt;B-&gt;C(1.0) A-&gt;C(2.0)。此时导入C(2.0) FCFS策略。A-&gt;B-&gt;C(1.0) A-&gt;B-&gt;C(2.0)。此时导入C(1.0) 排除依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;3.2.7&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;apache-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 引入了rocketmq,但是不想引入rocketmq里面的apache-lang就可以用exclusions元素进行排除。 排除的时候只需要定位groupId和artifactId就可以确定这个依赖。 setting.XMLlocalRepository本地仓库路径默认值为:$ {user.home} /.m2 / repository1&lt;localRepository&gt;D:/Program Files/Apache/maven-repository&lt;/localRepository&gt; interactiveModeMaven是否应该尝试与用户进行交互以进行输入。默认为:true usePluginRegistryMaven是否单独使用plugin-registry.xml文件来管理插件版本默认值为:false offline设置maven是否应该在全离线模式下运行。默认值为:false proxiesproxies表示maven的代理123456789101112&lt;proxies&gt; &lt;proxy&gt; &lt;id&gt;optional&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;username&gt;proxyuser&lt;/username&gt; &lt;password&gt;proxypass&lt;/password&gt; &lt;host&gt;proxy.host.net&lt;/host&gt; &lt;port&gt;80&lt;/port&gt; &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt; &lt;/proxy&gt;&lt;/proxies&gt; proxies下可以设置多个proxy，使用ID进行唯一标识区分。 id: 每个代理的唯一标识. active: 代理的激活状态，默认值为:true。设置多个代理时，使用第一个active为true的代理。 protocol: 代理使用的协议。默认值为:http username: 代理需要认证时的用户名。 password: 代理需要认证时的密码。 host: 主机名 port: 端口号,默认值为:8080 nonProxyHosts: 表示指定哪些主机名不需要代理，可以用”|” 分隔多个主机名，也支持通配符”*“; server用于连接远程仓库时的安全认证123456789101112&lt;servers&gt; &lt;server&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;username&gt;deployment&lt;/username&gt; &lt;password&gt;deployment&lt;/password&gt; &lt;privateKey&gt;$&#123;usr.home&#125;/.ssh/id_dsa&lt;/privateKey&gt; &lt;passphrase&gt;some_passphrase&lt;/passphrase&gt; &lt;filePermissions&gt;664&lt;/filePermissions&gt; &lt;directoryPermissions&gt;775&lt;/directoryPermissions&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/server&gt;&lt;/serves&gt; id: id是最关键的，这个id必须与需要认证的repository元素的id完全一致才行，换句话说，正式这个id将认证信息和仓库配置联系在了一起。 username: 用户名 password: 密码 privateKey: 鉴权时使用的私钥位置 passphrase: 鉴权时使用的私钥密码。 filePermissions: 文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。 directoryPermissions: 目录被创建时的权限 configuration: 传输层额外的配置项 mirrors仓库的镜像12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;all repository mirror&lt;/name&gt; &lt;url&gt;http://172.16.21.3:8081/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; id,name,url与仓库的配置相同 id: 仓库的唯一标识。 name: 仓库名 url: 仓库的地址.http://maven.net.cn/content/groups/public/ 是 中央仓库 http://repo1.maven.org/maven2/ 在中国的镜像。 mirrorOf：*表示任何对中央仓库的请求都会被转到镜像仓库中。profile个性配置文件，可以通过不同的方式激活。激活条件全部满足时激活该配置文件 1234567891011121314151617181920&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;activation&gt; ··· &lt;/activation&gt; &lt;repositories&gt; &lt;repository&gt; ··· &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; ··· &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; id: 配置文件的唯一标识 activation: 激活方式 repositories: 依赖仓库 pluginRepositories: 插件仓库 activation123456789101112131415161718&lt;activation&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;jdk&gt;1.6&lt;/jdk&gt; &lt;os&gt; &lt;name&gt;Windows 7&lt;/name&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;property&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;file&gt; &lt;exists&gt;$&#123;basedir&#125;/file2.properties&lt;/exists&gt; &lt;missing&gt;$&#123;basedir&#125;/file1.properties&lt;/missing&gt; &lt;/file&gt;&lt;/activation&gt; activeByDefault: 当设置为true时，没有其他profile激活时，自动激活。 jdk: 当JDK版本满足时激活，可以用开闭区间表示一个JDK满足的范围。 os: 当操作系统满足时激活 name: 操作系统 family: 操作系统类型 arch: 操作系统位数 version: 操作系统版本 property: 键值对的形式,当只存在name时。hello属性存在,即可激活。当name，value都存在时，hello属性存在，并且hello属性的value为world时可以激活。 name: hello value: world file: 表示当文件存在或不存在的时候激活 exists: 该路径上的文件存在时激活 missing: 该路径上的文件不存在时激活 repository123456789101112131415161718&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;codehausSnapshots&lt;/id&gt; &lt;name&gt;Codehaus Snapshots&lt;/name&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;never&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;fail&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;url&gt;http://snapshots.maven.codehaus.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt;&lt;/repositories&gt; repositories中可以有多个repository,使用ID进行唯一标识区分。 id: 每个中央仓库的唯一标识。Maven自带的中央仓库使用的id为central，如果其他仓库声明也用该id，就会覆盖中央仓库的配置。 name: 仓库名 url: 中央仓库的地址。 releases: 表示开启仓库的发布版本下载支持。 enabled: 启用状态。默认值为:true。 updatePolicy: 更新时间，可选值有(always、daily、interval:minutes和never) always: 始终 daily: 每天 interval:minutes: 指定时间间隔(单位为分钟) never: 从不 checksumPolicy: 当Maven在部署项目到仓库的时候会连同校验文件一起提交，checksumPolicy表示当这个校验文件缺失或不正确的时候该如何处理，可选项有ignore、fail和warn。 ignore: 忽略 fail: 失败 warn: 警告 snapshots: 表示关闭仓库的快照版本下载支持。参数与releases类似 pluginRepository插件仓库与依赖仓库配置类似12345678910111213&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;http://central&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt; activeProfiles手动激活的构建配置文件列表，按照应用顺序指定。1234&lt;activeProfiles&gt; &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt; &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;&lt;/activeProfiles&gt; 上述配置表示激活所有。 pluginGroups插件组123&lt;pluginGroups&gt; &lt;pluginGroup&gt;org.mortbay.jetty&lt;/pluginGroup&gt;&lt;/pluginGroups&gt; 添加了上面的插件后就可以使用 1mvn jetty:run]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memchahed介绍]]></title>
    <url>%2F2018%2F10%2F11%2Fmemchahed%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[abstract 我们先抛出几个问题。 什么是缓存？为什么要有缓存？有哪些缓存技术以及他们的优缺点？]]></content>
  </entry>
  <entry>
    <title><![CDATA[js_JQuery]]></title>
    <url>%2F2018%2F08%2F29%2FJS-JQuery%2F</url>
    <content type="text"><![CDATA[abstract 字符串操作substring截取字符串(“有始无终”) var s = &quot;abcd&quot;; s.substring(1,3); -&gt; &quot;bc&quot; $.trim()$.trim() 函数用于去除字符串两端的空白字符。 var s = &quot; 123 123 456 &quot; $.trim(s); -&gt; &quot;123 123 456&quot; AJAX一、$.ajax()该方法是 jQuery 底层 AJAX 实现。 1、async类型：Boolean 默认值: true。 默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。两条并列AJAX要区分先后顺序的话应采取同步 2、cache类型：Boolean 默认值: true。 dataType 为 script 和 jsonp 时默认为 false。设置为 false 将不缓存此页面。 3、contentType类型：String 默认值: “application/x-www-form-urlencoded”。 请求发送信息至服务器时内容编码类型。默认值适合大多数情况。如果你明确地传递了一个content-type给 $.ajax() 那么它必定会以设定类型发送给服务器（即使没有数据要发送）。 4、success类型：Function 请求成功后的回调函数。 参数：由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串。 这是一个 Ajax 事件。 5、error类型：Function 默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。 有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。 如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是 “timeout”, “error”, “notmodified” 和 “parsererror”。 这是一个 Ajax 事件。 6、type类型：String 默认值: (“GET”)。 请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。 7、url类型：String 默认值: 当前页地址。 发送请求的地址。 8、dataType类型：String 预期接收服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断. “xml”: 返回 XML 文档，可用 jQuery 处理。 “html”: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。 “script”: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 “cache” 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载） “json”: 返回 JSON 数据 。 “jsonp”: JSONP 格式。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 “text”: 返回纯文本字符串 9、data类型：String 发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[“bar1”, “bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。 $.ajax({ type: &quot;POST&quot;, async: true, cache: true, url: &quot;ajax.php&quot;, dataType: &quot;json&quot;, data: {&quot;username&quot;: &quot;bbdog&quot;,&quot;password&quot;: 123456}, contentType: &quot;&quot;, success: function(msg) { console.log(msg) }, error: function() { console.log(&quot;error&quot;) } }) 二、$.post()语法jQuery.post(url,data,success(data, textStatus, jqXHR),dataType) url必需。规定把请求发送到哪个 URL。 data可选。映射或字符串值。规定连同请求发送到服务器的数据。 success(data, textStatus, jqXHR)可选。请求成功时执行的回调函数。 dataType可选。规定预期的服务器响应的数据类型。 默认执行智能判断（xml、json、script 或 html）。 三、$.get()$(selector).get(url,data,success(response,status,xhr),dataType) 参数于post()方法类似 选择器.val().html().text() 操作DOMremove()和empty()删除元素/内容 如需删除元素和内容，一般可使用以下两个 jQuery 方法： remove() - 删除被选元素（及其子元素） empty() - 从被选元素中删除子元素 append()和appendTo$(selector).append(content) $(selector).append(function(index,html)) $(content).appendTo(selector) Tips:append() 和 appendTo() 方法执行的任务相同。不同之处在于：内容和选择器的位置，以及 append() 能够使用函数来附加内容。 .val().html().text() text()//返回文本内容 $(selector).text(); //设置文本内容 $(selector).text(content); //使用函数设置内容 $(selector).text(function(index,oldcontent)) $(selector).attr({attribute:value, attribute:value ...}) class//添加样式 $(selector).addClass(class) //同时添加多个中间用空格隔开 //移除样式 $(selector).removeClass(class) 属性attr //返回属性值 $(selector).attr(attribute) //设置属性值 $(selector).attr(attribute,value) //移除属性值 $(selector).removeAttr(attribute) 可以操作标签的属性和样式的属性；css //返回属性值 $(&quot;p&quot;).css(&quot;background-color&quot;); //设置属性值 $(&quot;p&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;); 隐藏与显示查看显示与隐藏 $(&apos;div:visible&apos;); // 所有可见的div $(&apos;div:hidden&apos;); // 所有隐藏的div 1.hide()和show() //隐藏 $(selector).hide(speed,callback); //显示 $(selector).show(speed,callback); 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。 可选的 callback 参数是隐藏或显示完成后所执行的函数名称。 2.toggle() //显示被隐藏的元素，并隐藏已显示的元素： $(selector).toggle(speed,callback); 3.css(‘display’,*) $(&quot;#id&quot;).css(&apos;display&apos;,&apos;none&apos;);//隐藏 $(&quot;#id&quot;).css(&apos;display&apos;,&apos;block&apos;);//显示 或者 $(&quot;#id&quot;)[0].style.display=&apos;none&apos;; 4.css(‘visibility’,*) $(&quot;#id&quot;).css(&apos;visibility&apos;,&apos;hidden&apos;);//元素隐藏 $(&quot;#id&quot;).css(&apos;visibility&apos;,&apos;visible&apos;);//元素显示 display:none与visible:hidden的区别 visible保留&apos;物理空间&apos;,display不保留&apos;物理空间&apos; 数据类型转换typeof()typeof()可以用来检测给定变量的数据类型,它将返回一个字符串，表示表达式的类型，而表达式的类型只有六种可能： number string boolean object function undefined 转为数字类型转为Int var iNum1 = parseInt(“1234blue”); -&gt; 1234 var iNum2 = parseInt(“oxA”); -&gt; 10 var iNum3 = parseInt(“22.5″); -&gt; 22 var iNum4 = parseInt(“blue”); -&gt; NaN 基模式转为Int var iNum1 = parseInt(“AF”,16); -&gt; 175 var iNum2 = parseInt(“10″,2); -&gt; 2 var iNum3 = parseInt(“10″,8); -&gt; 8 var iNum4 = parseInt(“10″,10); -&gt; 10 如果以0开头最好使用十进制基模式 var iNum1 = parseInt(“010″); -&gt; 8 转为Float var fNum1 = parseFloat(“1234blue”); -&gt; 1234.0 var fNum2 = parseFloat(“0xA”); -&gt; NaN var fNum3 = parseFloat(“.22.5″); -&gt; 0.22 var fNum5 = parseFloat(“0908″); -&gt; NaN var fNum6 = parseFloat(“blue”); -&gt; NaN 转为字符串类型使用toString()方法,常用源数据有Boolean、number、String 1.Boolean var b = true; b.toString(); -&gt; &quot;true&quot; 2.number[默认模式] var num1 = 10.00; num1.toString(); -&gt; &quot;10&quot; 3.number[基（进制基数）模式] var iNum = 10; alert(iNum.toString(2)); -&gt; “1010″ alert(iNum.toString(8)); -&gt; “12″ alert(iNum.toString(16)); -&gt; “A” replace()String.replace(regexp/substr,replacement); var s = &quot;abcd&quot; s = s.replace(&quot;a&quot;,&quot;z&quot;); -&gt; &quot;zbcd&quot; s = s.replace(/c/,&quot;z&quot;); -&gt; &quot;zbzd&quot; s = s.replace(/z/g,&quot;a&quot;); -&gt; &quot;abad&quot; s = s.replace() 将json对象序列化为json字符串contentType: ‘application/json’JSON.stringify(JSONObject) 服务器端可以用JSON.parse将json串还原成JSONObject 数字计算“四舍六入五成双”的toFixed 当有效位后一位，≤4 时舍去,≥6时进1；当等于5时，先判断5后是否还有数，有则进；无数时再判断5数的奇偶性，前为奇数则进1，否则舍去。不同浏览器执行不同ES标准，计算时可能有所不同（尤其IE浏览器） toFixed()返回数字形式的字符串,可参与运算可以用toFixed补全小数点数。 取整Math.round()可先*100 再/100 用于四舍五入。 和传统四舍五入最接近，当有效位后一位，≤4 时舍去,≥6时进1，当等于5时，向正无穷方向取整 待认领window.confirm .dialog .parents $(this) .siblings .not .eq .each .prev .live .is .before .match 数据为空的几种方式null “” undefined正则]]></content>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA]]></title>
    <url>%2F2018%2F08%2F02%2FIntelliJ-IDEA%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
  </entry>
  <entry>
    <title><![CDATA[FreeMarker]]></title>
    <url>%2F2018%2F08%2F02%2FFreeMarker%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
  </entry>
  <entry>
    <title><![CDATA[SSM]]></title>
    <url>%2F2018%2F08%2F02%2FSSM%2F</url>
    <content type="text"><![CDATA[abstract 主标签次级标签CRUD标签### 通用参数id 唯一标识parameterType 出入参数类型 flushCachestatementTypetimeout resultTyperesultMapuseCache useGeneratedKeyskeyProperty其他参数：]]></content>
  </entry>
  <entry>
    <title><![CDATA[SQL]]></title>
    <url>%2F2018%2F08%2F02%2FSQL%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML]]></title>
    <url>%2F2018%2F08%2F02%2FHTML%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于如何学习方法的总结]]></title>
    <url>%2F2018%2F08%2F02%2F%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[记一些学习技术的方法，用高效的方法去学习新的东西，花点时间去学习 学习的技巧收益会比“努力学习”更高，就像提升加速度比提升速度走的更远。 给一个时间限度首先需要先初步了解要学习的技术，对需要掌握的点有个初步认识。再根据自己可支配的学习时间估算出一个比较合理的截止时间。 动手敲敲怎么防止不学完就忘好记性不如烂笔头，可以搭建一个自己的博客，将自己的收获写在里面。不在乎有多少人去看，重在在于这个整理的过程。费曼学习法中指出，当你能熟练的把一个东西向别人讲述的时候，你也就学会了这个东西。 不放过细小的部分，只要是写出来的东西都要对他负责，不用整理的很细致，把涉及的源码都剖析一遍。重在整个文章能围绕一条中心线走下去。看起来很有层次性。 当你把写博客成为一种习惯，时间长了看看之前写的博客对自己也是一种收获。]]></content>
      <categories>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
        <tag>高效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java]]></title>
    <url>%2F2018%2F08%2F02%2Fjava%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
  </entry>
  <entry>
    <title><![CDATA[English]]></title>
    <url>%2F2017%2F12%2F28%2FEnglish%2F</url>
    <content type="text"><![CDATA[书到用时方恨少 事非经过不知难 English Chinese editor 编辑 scheme 方案 import 输入 export 输出 duplicate 副本 consoles 控制台 comments 注释 string 字符串 search 搜索 beautiful 美丽的 domain 域名 RequestMapping 请求映射 method 请求类型 repository 版本库、仓库 difference 差别 status 现状 check 檢查 Invoice 发票 SalesOrder 售货单 Mapping 映射、制图 Sources 源 template 模板]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 勿忘启蒙之师 Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
