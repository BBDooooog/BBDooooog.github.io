<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java-集合]]></title>
    <url>%2F2019%2F09%2F25%2FJava-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合类总结 ListIterator(迭代器)：读取删除、删除操作，支持fail-fast机制； Enumeration(枚举类)：只能读取，不支持fail-fast机制； fail-fast机制：读取数据时判断当前集合对象是否被别的线程修改过； ArrayList 动态数组，默认初始值：10，支持序列化， 扩容方式：newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);再与最小值最大值比较； 线程不安全，方法未使用synchronized关键字修饰; 支持Iterator，存在fail-fast机制，不支持Enumeration； 应用环境：频繁随机访问；避免中间插入、删除操作；用于单线程操作； 遍历：下标遍历最快 LinkedList 双向循环链表，初始值：0，支持序列化； 扩容方式：随用随长； 线程不安全，fail-fast机制，方法未使用synchronized关键字修饰; 支持Iterator，存在fail-fast机制，不支持Enumeration； 应用环境：频繁中间插入、删除操作；用于单线程操作；可以作为FIFO的队列，可以作为FILO的栈； 遍历： Vector 动态数组，默认初始值：10，不支持序列化； 扩容方式：newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity)，capacityIncrement为构造方法中指定的增长因子； 线程安全，方法使用synchronized关键字修饰; 支持Iterator，存在fail-fast机制，支持Enumeration； 应用环境：多线程操作； 遍历：for(Object obj:Object[])方式最快 Stack 继承Vector,数组实现，先进后出(FILO, First In Last Out)队列，不支持序列化。 push():数组末尾增加追加元素；pop()：数组末尾删除元素；peek():返回数组末尾元素； 继承Vector,方法使用synchronized关键字修饰; 支持Iterator，存在fail-fast机制，支持Enumeration； MaphashCode(): equals(): HashMapTreeMapHashTableWeakHashMapLinkedHashMapSetHashSetTreeSetLindHashSet]]></content>
      <categories>
        <category>JAVA集合框架</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>Java</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盘山十二时辰]]></title>
    <url>%2F2019%2F09%2F13%2FPanShan%2F</url>
    <content type="text"><![CDATA[盘山十二时辰 赛前准备早知有盘山，何必下江南。报名之后就开始紧锣密鼓的在为盘山准备着，迫不及待。从网上的攻略中搜寻 较为清晰的线路图爬升图，从户外软件上下载路线在google earth上面研究，制定计划，现在看来，所有的计划在高温面前不值一提。 行程从北京出发，因为周天早上出发，所以买了周六早上的票，先去住下，也正好膜拜一下100km大神起跑的英姿。提前定了一个农家院，盘山景区周边的农家院发展规模很大，景区正门西边有着数不清的农家院，住宿条件对标快捷酒店，更关键的是这里的人儿热情好客，和他们聊聊天。尝尝他们自己做的菜，尤其是大锅鱼，给我留下了不可磨灭印象，哧溜。收拾妥当两点半来到牌楼下，虽然温度灼人，但选手们的热情更为高涨。刚刚完成八百流沙的百日侠-林海激动的介绍着这场准备了两年才与大家见面的100公里。 没过多久，视频直播平台就传来了他们赛道上的身影，恰巧同行的3个100大神都有上镜，状态不错，而周天正好也是彦博的生日，他希望用盘山首百来让今年的生日更有意义一些。这次的计时的服务由东软赛克提供，他可以订阅选手，当他们sp点打卡的时候你也会同步接受到推送，晚上一边和同行伙伴准备明天的装备，一边关注着100的伙伴的赛况，三个人越野经验都特别丰富，看着他们的实时排名一次次向前就踏实了很多。 寅初 3点，狗在外面吵架，五点鸡开始叫，七点起床。一脸疲惫的吃了些院里大哥准备的早饭就前往广场。值得一提的是，我们住的不算近，但走路也就五六分钟就到了景区广场。广场上人山人海35组10亲子组同时出发。盘山组委会，百日侠在台上热情洋溢的坐着动员。所有的人都已迫不及待的过程 起点~CP1⭐ 2公里盘山公路 + 4公里的景区台阶路 + 999台阶 + 500米下山台阶。 这4公里的台阶路累计爬升有500多，跟着同行的瑶神跑了3公里就再也没见过瑶神。到了999台阶的时候不要抬头，因为抬头你也看不到顶。补给点稍作补给，确认打卡成功就迫不及待的的去追赶瑶神。CP1~CP2⭐ 4公里下行盘山公路 + 4公里技术路段 4公里左右的下行盘山公路可以撒欢的跑了，但有很多景区接驳车，跑的时候需要注意路况。盘山公里结束就进入了真正的技术赛道，这也是第一个让我感到，上山比下山舒服的赛道，路线图上感觉像是在馒头上跑，实际上我们是在锯齿上跑，而且一山更比一山高。三公里技术路段以后是一公里的下坡，直达cp2，因为是沙土路，膝盖力量不行，很本不敢跑太快。Cp2吃了根雪糕，和外国小伙聊了会天，我用蹩脚英语给他说，他用流利中文回答我。让我至今“怀恨在心”的是我先出了补给点，他在后面喊，我一会超过你，当时我就在想，前面14公里都没赶上我还好意思说超我。然后，然后我就然后他比我提前一个小时完赛。Cp2~cp10 ⭐⭐⭐ 2公里乡村道路 + 3公里山脊 + 1公里下山路 + 2公里乡村公路 这一段我觉得是整个35公里最有技术的一段，村里跑了两公里就来到山下，之字形的赛道上到第一个小高峰，从此不知树林是何物，35度的太阳，光秃秃的山脊，这一段降温用水比喝水多。三公里的山脊最后，有个50米左右，70度的坡作为最后的磨炼，手脚并用爬上去。 开始下坡，仍然是水平不够跑不起来的技术路段，头这么大的石头散落一路，而且都是活动的。其中有一段像是冰川活动的痕迹，山谷里有一条石头流。 石头流结束可算是能跑起来了，这里的路面零星散落鸡蛋大小的石块，落脚要十分小心。跑了一公里，一路的高温，内心十分的渴望补给点，这个补给点有肉吃。遇到一个摄影师，说还有一公里，于是开始用6分左右的配速冲向补给点，这一冲，就是接近3公里。你家这1公里有点长啊，这一段匀速跑身体温度直线上升。到了补给点先物理降温，再喝了点藿香正气液预防一下。也许是东西太好吃，也许是志愿者们的服务太好，这一歇就是30分钟。懊悔不已。 CP10~CP11⭐ 6公里缓坡 + 4公里公路 和一个多跑了五公里的小姐姐一起出的补给点。小姐姐说我上山慢是膝盖不行，我下山快是因为我不怕死。接下来这10公里我是真的见识到这句话真实的样子。这一段路相对平缓上下交错，但这时大腿已经酸痛，下山已经完全跑不起来，和一个大哥从起点一直相伴到这里，路上交流着关于跑步的观点，跑步不能只图快，还要跑得长久，二三十岁能跑，五六十岁也能跑。两个补给点之间增加了一个临时补给点，这个补给点以后是3 4公里的上行盘山公路，顶着太阳，咸鱼般的向少林寺快走着。 CP11~终点⭐⭐⭐ 因为少一个补给点耽搁太久，在这最后一个补给点，我放弃了我向往的的羊汤，喷了些云南白药，看着另外两个同行伙伴惬意的坐在收容车上发来的问候，没敢停，继续走着，因为体力基本耗尽，全靠毅力在走着，听着旁边大哥报着还有多少米的爬升。终于看到了下山的路，依然是向下挪着，每有一个人超过我，我就数着我的实时名次，想追，但真的追不动。直到赛道和出发时赛道重合后才逐渐迈开腿，最后的力气跑了两公里到达终点收容车小队已经在终点等着，让我最吃惊的是彦博竟然退赛了，出发前看到他的名次还是比较靠前的，很多原因导致他没能到达终点，真的觉得很惋惜，不便多说，只得心里一句：“生日快乐，明年再来”。 让康复人员放松了下肌肉，处理了伤口，水泡。接着买了晚上最后一班回北京的门票。到家已经是十二点半了，第二天七点半起床，收拾，上班。不是我想起，是酸的睡不着。 总结第一次盘山越野可以用完美来形容，一切恰到好处，无论是赛事安排和赛道设置都是有水准的，怪不得说，早知有盘山，何必去柴古。]]></content>
      <categories>
        <category>越野赛</category>
      </categories>
      <tags>
        <tag>盘山</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaIO-基础]]></title>
    <url>%2F2019%2F08%2F26%2FJavaIO-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[初步理解JavaIO]]></content>
      <categories>
        <category>JavaIO</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown-markdown不常用小技巧]]></title>
    <url>%2F2019%2F08%2F20%2FMarkdown-markdown%E4%B8%8D%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[一些不常用但有时又能起到画龙点睛效果的小技巧 Markdown与H5不得不说的秘密Markdown的页内跳转必把大象塞进冰箱更为简单 step1：增加锚点，其实就是给标签加一个id, 12&gt; &lt;span id="jump"&gt;Hello World&lt;/span&gt;&gt; step2：跳转 12&gt; [XXXX](#jump)&gt; 试了一下用class标记，好像是不行。检查页面元素发现markdown转为H5之后使用的herf 1&lt;a href=&quot;.jump&quot;&gt;XXXX&lt;/a&gt;]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-数据库连接池]]></title>
    <url>%2F2019%2F07%2F16%2FJava-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[abstract 之前有写过文章介绍了java连接数据库的流程，该流程是一个线程请求访问数据库时必要的步骤，但是网站并发量高时，每个线程都要连接数据库，操作数据库，断开数据库连接。有时操作数据库的时间占比非常小，时间花销都用在数据库的连接与断开上。导致了并发访问瓶颈。 这个时候数据库与应用线程就是一个生产者消费者的关系，解决生产消费者关系的方案之一就是引入资源池. 生产者生产的东西一直朝池子中放，消费者从池子中获取自己想要的资源。数据库与线程也是，线程需要连接，那就把连接都初始化好，放在池子里，线程直接获取连接，操作数据库，用完之后归还连接。这样每个线程就不需要和自己和数据库建立断开连接，连接已经由连接池创建好，只需要拿过来用即可。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>连接池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-JDBC连接数据库步骤]]></title>
    <url>%2F2019%2F07%2F15%2FJava-JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[abstract 加载JDBC驱动类（以mysql驱动为例）JDBC定义了一套接口，数据库产品的提供商会实现这些接口来提供自己的数据库驱动程序，这是个很好的面向接口编程的实例，想要替换数据库的时候只需要替换驱动程序就可以了(这里暂不考虑不同数据库之间的数据类型和SQL语法的差异) 1234567try &#123; // 加载MySql的驱动类 Class.forName("com.mysql.jdbc.Driver"); &#125; catch(ClassNotFoundException e) &#123; System.out.println("找不到驱动程序类 ，加载驱动失败！"); e.printStackTrace(); &#125; 加载驱动类的时候具体执行了哪些操作呢？ Class.froName()方法源码 123456@CallerSensitivepublic static Class&lt;?&gt; forName(String className) throws ClassNotFoundException &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); return forName0(className, true, ClassLoader.getClassLoader(caller), caller);&#125; Class.forName0()方法源码 12345/** Called after security check for system loader access checks have been made. */private static native Class&lt;?&gt; forName0(String name, boolean initialize, ClassLoader loader, Class&lt;?&gt; caller) throws ClassNotFoundException; java7官方文档中对该方法的描述 Returns the Class object associated with the class or interface with the given string name, using the given class loader. Given the fully qualified name for a class or interface (in the same format returned by getName) this method attempts to locate, load, and link the class or interface. The specified class loader is used to load the class or interface. If the parameter loader is null, the class is loaded through the bootstrap class loader. The class is initialized only if the initialize parameter is true and if it has not been initialized earlier. 返回一个给定类或者接口的一个 Class 对象，如果没有给定类加载器， 那么会使用根类加载器。如果 initalize 这个参数传了 true，那么给定的类如果之前没有被初始化过，那么会被初始化。 再回过头来看看com.mysql.jdbc.Driver类 123456789101112public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws SQLException &#123; &#125; static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException("Can't register driver!"); &#125; &#125;&#125; 刚才说到类会被初始化，类初始化的时候静态方法会被执行。即DriverManager.registerDriver(new Driver());,也就是说一开始我们加载驱动的时候执行DriverManager.registerDriver(new Driver());也是一样的。 JDBC4.0以后就不用再手动加载数据库驱动了，在DriverManager.loadInitialFrivers()方法中有这么一段代码 12345678910String drivers;try &#123; drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() &#123; public String run() &#123; return System.getProperty("jdbc.drivers"); &#125; &#125;);&#125; catch (Exception ex) &#123; drivers = null;&#125; 他会检查系统配置中名为jdbc.drivers的配置参数，并找到对应的数据库驱动。 拼接JDBC连接URL连接URL格式如下 1jdbc:mysql://[host:port],[host:port].../[database][?参数名1][=参数值1][&amp;参数名2][=参数值2]... 例如： 12345jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=gbk;# useUnicode=true：表示使用Unicode字符集。# 如果characterEncoding设置为gb2312或GBK，本参数必须设置为true。# characterEncoding=gbk：字符编码方式。 创建数据库连接1234567891011121314要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象该对象就代表着一个数据库的连接使用DriverManager的getConnectin(String url, String username, String password)方法传入指定的连接的数据库的路径、数据库的用户名和密码来获得。// 连接MySql数据库，用户名和密码都是root String url = "jdbc:mysql://localhost:3306/test"; String username = "root"; String password = "root"; try &#123; Connection con = DriverManager.getConnection(url , username , password); &#125; catch(SQLException se) &#123; System.out.println("数据库连接失败！"); se.printStackTrace(); &#125; 创建Statement实例12345678要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3种类型： 1、执行静态SQL语句。通常通过Statement实例实现。 2、执行动态SQL语句。通常通过PreparedStatement实例实现。 3、执行数据库存储过程。通常通过CallableStatement实例实现。 具体的实现方式： Statement stmt = con.createStatement(); PreparedStatement pstmt = con.prepareStatement(sql); CallableStatement cstmt = con.prepareCall("&#123;CALL demoSp(? , ?)&#125;"); 执行SQL语句…… 操作完数据库后关闭连接12345678910111213141516171819202122232425操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，连接操作如果是入栈顺序的话，关闭连接的顺序那就是出栈顺序： 1、关闭记录集 2、关闭声明 3、关闭连接对象 if (rs != null) &#123; // 关闭记录集 try &#123; rs.close(); &#125; catch(SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (stmt != null) &#123; // 关闭声明 try &#123; stmt.close(); &#125; catch(SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null) &#123; // 关闭连接对象 try &#123; conn.close(); &#125; catch(SQLException e) &#123; e.printStackTrace(); &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库-连接数相关命令]]></title>
    <url>%2F2019%2F07%2F15%2F%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%BF%9E%E6%8E%A5%E6%95%B0%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[abstract 连接池 连接 最大连接数 查看mysql最大连接数1SHOW VARIABLES LIKE 'max_connections'; 设置mysql最大连接数如果有统计连接池使用情况的日志最好，通过日志统计出平均值，峰值。然后基于平均值再高一些设置初始连接数，基于峰值再高一些设置最大连接数。 设置mysql最大链接数的方式有两种，一种是配置文件设置，一种是数据库设置。 配置文件设置修改mysql的配置文件中max_connections项 1max_connections=1000 修改设置需要重启数据库才能生效。 命令设置命令行修改最大连接数 1set global max_connections = 1000 常见数据库状态命令 查看线程 123456# 查看当前数据库的连接状态show status like 'Threads%';# threads_cached:缓存的连接# threads_connected：建立的连接数量# threads_created：创建过的线程数量# threads_running：激活的连接数量 | Variable | Value | | —————– | ———- | | Threads_cached | 0 | | Threads_connected | 86 | | Threads_created | 2226660253 | | Threads_running | 4 | 查看当前连接状态 12#root用户可以查看所有正在连接的信息show processlist; 查看数据库运行状态 12# 查看数据库运行状态show status 返回结果相当丰富。 参数详解见官方文档。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>连接数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis-基础]]></title>
    <url>%2F2019%2F07%2F11%2FRedis-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[你在别的地方也能看到的Redis学习笔记。 Redis老生常谈 Redis是由C语言编写，支持网络交互，基于内存也可以持久化的Key-Value(非关系型数据库)。 其实我就知道啥叫C语言,其他两个描述我搜了一下。 redis服务器与客户端交互方式redi处理客户端的流程，通过TCP请求或者Unix socket【①】建立一个socket链接，然后检查最大连接数，再进行内部处理。 先建立链接，再告诉超过最大连接数，再返回错误，断开连接。 服务端处理多个客户端命令的顺序 socket号的大小 kernal报告事件的先后顺序 ①：UNIX Domain SOCKET 是在Socket架构上发展起来的用于同一台主机的进程间通讯（IPC）。它不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序列号应答等。只是将应用层数据从一个进程拷贝到另一个进程。 最大连接数输出缓冲区限制理解为港口运出商品，正常情况风调雨顺，政策可爱。 第一种情况，马上要提升关税了，港口疯狂向外运送商品，一个简单的命令返回的数据太大。 第二种情况是，海上天气不好，来往的船只少或者航速缓慢，但是有很多商品等待运出，在港口堆积，服务器朝客户端发送速率无法及时发送输出缓冲区的数据。 这两种情况都会导致占用内存过高，系统崩溃。redis采取的机制是限制输出缓冲区大小，和打黑除恶。 限制大小，当某一个客户端的缓冲区超过设定的最大值时，直接断开与该客户端的连接，贸易逆差，不和你玩。 打黑除恶，当某一个客户端长时间占用大空间也会断开连接。 实际情况 对普通客户端来说，限制为0，也就是不限制，因为普通客户端通常采用阻塞式的消息应答模式，如：发送请求，等待返回，再发请求，再等待返回。这种模式通常不会导致输出缓冲区的堆积膨胀。 对于 Pub/Sub 客户端来说，大小限制是32m，当输出缓冲区超过32m时，会关闭连接。持续性限制是，当客户端缓冲区大小持续60秒超过8m，也会导致连接关闭。 而对于 Slave 客户端来说，大小限制是256m，持续性限制是当客户端缓冲区大小持续60秒超过64m时，关闭连接。 输入缓冲区限制比较暴力，当客户端传输的请求大小超过1G时，服务端会直接关闭连接。 这种方式可以有效防止一些客户端或服务端 bug 导致的输入缓冲区过大的问题。 Client超时对当前的 Redis 版本来说，服务端默认是不会关闭长期空闲的客户端的。但是你可以修改默认配置来设置你希望的超时时间。比如客户端超过多长时间无交互，就直接关闭。同理，这也可以通过 CONFIG SET 命令或者修改 redis.conf 文件来配置。 值得注意的是，超时时间的设置，只对普通客户端起作用，对 Pub/Sub 客户端来说，长期空闲状态是正常的。 另外，实际的超时时间可能不会像设定的那样精确，这是因为 Redis 并不会采用计时器或者轮训遍历的方法来检测客户端超时，而是通过一种渐近式的方式来完成，每次检查一部分。所以导致的结果就是，可能你设置的超时时间是10s，但是真实执行的时间是超时12s后客户端才被关闭。 client list id=2 addr=10.117.146.21:55330 fd=6 name= age=1759348 idle=0 flags=S db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=replconf 解释为 addr: 客户端的TCP地址，包括IP和端口fd: 客户端连接 socket 对应的文件描述符句柄号name: 连接的名字，默认为空，可以通过 CLIENT SETNAME 设置age: 客户端存活的秒数idle: 客户端空闲的秒数flags: 客户端的类型 (N 表示普通客户端，更多类型见 http://redis.io/commands/client-list)omem: 输出缓冲区的大小cmd: 最后执行的命令名称 redis的优势 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) 支持丰富数据类型，支持string，list，set，sorted set，hash 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除 redis的应用场景缓存 (1) 对于一些要返回给前端数据的缓存，当有大量数据库sql操作时候，为了避免每次接口请求都要去查询数据库，可以把一些数据缓存到redis中，这样是直接从内存中获取数据，速度回增快很多。 (2) web端用户，用于登陆缓存session数据，登陆的一些信息存到session中，缓存到redis中 队列 redis中提供了list接口，这个list提供了lpush和rpop，这两个方法具有原子性，可以插入队列元素和弹出队列元素。 数据存储 redis是非关系型数据库，可以把redis直接用于数据存储，提供了增删改查等操作，因为redis有良好的硬盘持久化机制，redis数据就可以定期持久化到硬盘中，保证了redis数据的完整性和安全性。 redis锁实现防刷机制 redis锁可以处理并发问题,redis数据类型中有一个set类型，set类型在存储数据的时候是无序的，而且每个值是不一样的，不能重复，这样就可以快速的查找元素中某个值是否存在，精确的进行增加删除操作。]]></content>
  </entry>
  <entry>
    <title><![CDATA[注解-常用注解]]></title>
    <url>%2F2019%2F07%2F11%2F%E6%B3%A8%E8%A7%A3-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Java注解，做个笔记。 前两天学习Spring Boot整合Redis时候写的测试类中,地址栏输入请求后页面找不到。然后就查了一下，也开始了Java注解的学习之路。 123456789101112@Controller@RequestMapping(value = "/test")public class TestDBController &#123; @Autowired private RedisUtils redisUtils; @RequestMapping(value = "/getRedis") public String getRedis()&#123; redisUtils.set("a",1); return redisUtils.get("a").toString(); &#125;&#125; 这要从@RequestMapping说起 @RequestMapping这个注解会将 HTTP 请求映射到Control的处理方法上. 123456789101112131415@RestController@RequestMapping("/home")public class IndexController&#123; @RequestMapping("/") public String get()&#123; return "methodName IndexController.get()" &#125; @RequestMapping("/index") public String index()&#123; return "methodName IndexController.index()" &#125; &#125; /home请求由get()方法处理，返回methodName IndexController.get() /home/index请求由index()方法处理,返回methodName IndexController.index() 基本上是我接触到的第一个注解了。 还可以指定一个多个请求指向一个处理方法 12345678910@RestController@RequestMapping("/home")public class IndexController&#123; @RequestMapping(value = &#123;"","/page","all"&#125;) public String get()&#123; return "methodName IndexController.get()" &#125;&#125; /home,/home/page./home/all都由get()方法处理。 @RequestMapping还可以指定请求方式 123456789101112131415@RestController@RequestMapping("/home")public class IndexController&#123; @RequestMapping() public String get()&#123; return "methodName IndexController.get()" &#125; @RequestMapping(method = RequestMethod.POST) public String post()&#123; return "methodName IndexController.post()" &#125; &#125; 默认的请求都是get,指定请求方式时跳转对应的处理方法处理方法，使用post请求/home时返回methodName IndexController.post(). 常用功能先到这里吧，但是我不禁陷入了沉思，还有很多用法，在现在的项目里用不到，我到底要不要整理，不整理，就感觉学的不透彻（虽然整理了还是会忘掉）。可是整理吧，就是个蚂蚁窝，可能把整个草原都翻一遍。时间太长，用不到就是在做无用功。希望有过这种经历，并有想法的可以通过右下角告诉我。 @RequsetParam123456789101112131415@RestController@RequestMapping("/home")public class IndexController&#123; @RequestMapping("/getParamByName") public String getParamByName(@RequestParam(value="name",defaultValue="2") String id)&#123; return id; &#125; @RequestMapping("/getParamById") public String getParamById(@RequestParam() String id)&#123; return id; &#125;&#125; @RequestParam将请求参数绑定到处理方法的形参上。 /home/getParamByName?name=1,页面返回1,如果请求的时候没带参数将使用默认值2。 /home/getParamById?id=2,页面返回2.如果请求参数和形参同名情况下可以省略注解内的名称。其实，同名情况可以将@RequestParam都省略掉。 @ResponseBody@Responsebody 注解表示该方法的返回的结果直接写入 HTTP 响应正文（ResponseBody）中，一般在异步获取数据时使用，通常是在使用 @RequestMapping 后，返回值通常解析为跳转路径，加上@Responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP 响应正文中。 这就到了一开始说到了为什么类用了@Controller注释再用@RequestMapping返回字符串显示找不到页面的情况了。 可以给方法加上@ResponseBody或者将@Controller换成@RestController。 原来返回指定页面的也会因为使用了@RestController而显示路径名。 说道ResponseBody不说RequestBody有点对不住他 @RequestBodyGet请求没有请求体，要使用@RequestBody可以用post提交请求。 一个请求请求只有一个@RequestBody，一个请求可以有多个@RequestParam 123456@RequestMapping("/testRequestParam")public void requestParam(User user ,@RequestParam Integer userId, @RequestParam String userName,@RequestParam String password,@RequestParam String phone)&#123; System.out.println("userId=" + userId + "userName=" + userName + "password=" + password + "phone="+ phone); System.out.println(user.toString());&#125; userId=1userName=2password=3phone=4User(userId=1, userName=2, password=3, phone=4) GET使用x-www-form-urlencoded会报错 { “timestamp”: “2019-07-11T10:42:03.750+0000”, “status”: 400, “error”: “Bad Request”, “message”: “Required Integer parameter ‘userId’ is not present”, “path”: “/test/testRequestBody”} POST请求下@RequestParam获取使用x-www-form-urlencoded返回结果与GET请求使用form-data相同 但是如果想批量传参，就需要用到RequestBody 123456@RequestMapping("/testRequestBody") public void requestBody(@RequestBody List&lt;User&gt; userList)&#123; for (User user :userList)&#123; System.out.println(user.toString()); &#125; &#125; console: User(userId=1, userName=2, password=3, phone=4)User(userId=5, userName=6, password=7, phone=8)]]></content>
      <categories>
        <category>注解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springBoot-Redis]]></title>
    <url>%2F2019%2F07%2F10%2FspringBoot-Redis%2F</url>
    <content type="text"><![CDATA[abstract 本文主要为了学习Redis相关知识，使用springBoot整合单例Redis来操作Redis数据库。 Redis安装Redis安装详见Redis官网。 因为懒，现在在Windows上把Redis装成服务，.msi傻瓜包下载地址。 如果需要修改启动配置，可以到安装路径下的redis.windows-service.conf中修改。 Redis可视化工具的话推荐RedisClient,jar包点击运行，该有的功能都有，界面如下。 SpringBoot整合Redis、Jedismaven依赖 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; resources下合适位置新建配置文件redis.properties,等会引入自定义文件时要用到这个路径。 123456789101112131415161718redis.host=127.0.0.1redis.port=6379redis.password=nullredis.timeout=30000# 连接池最大连接数（使用负值表示没有限制）redis.maxTotal=30# 连接池中的最大空闲连接redis.maxIdle=10redis.numTestsPerEvictionRun=1024redis.timeBetweenEvictionRunsMillis=30000redis.minEvictableIdleTimeMillis=1800000redis.softMinEvictableIdleTimeMillis=10000# 连接池最大阻塞等待时间（使用负值表示没有限制）redis.maxWaitMillis=1500redis.testOnBorrow=trueredis.testWhileIdle=trueredis.blockWhenExhausted=false 使用自定义配置的方式加载redis.properties中的配置信息 这里要说一下jedis与redisTemplate的区别。 Jedis是Redis官方推荐的面向Java的操作Redis的客户端。 RedisTemplate是SpringDataRedis中对JedisApi的高度封装。 SpringDataRedis相对于Jedis来说可以方便地更换Redis的Java客户端，比Jedis多了自动管理连接池的特性，方便与其他Spring框架进行搭配使用如：SpringCache。 下文使用redisTemplate作为redis客户端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.bbdog.demo.properties;import com.bbdog.demo.utils.RedisUtils;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.PropertySource;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import org.springframework.stereotype.Component;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;@Component@Data@PropertySource(value = "classpath:config/redis.properties")@ConfigurationProperties(prefix = "redis")public class RedisConfig &#123; private String host; private Integer port; private String password; private Integer timeout; private Integer maxTotal; private Integer maxIdle; private Integer numTestsPerEvictionRun; private Integer timeBetweenEvictionRunsMillis; private Integer minEvictableIdleTimeMillis; private Integer softMinEvictableIdleTimeMillis; private Integer maxWaitMillis; private Boolean testOnBorrow; private Boolean testWhileIdle; private Boolean blockWhenExhausted; /** * JedisPoolConfig 连接池 * @return */ @Bean public JedisPoolConfig jedisPoolConfig() &#123; JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); // 最大空闲数 jedisPoolConfig.setMaxIdle(maxIdle); // 连接池的最大数据库连接数 jedisPoolConfig.setMaxTotal(maxTotal); // 最大建立连接等待时间 jedisPoolConfig.setMaxWaitMillis(maxWaitMillis); // 逐出连接的最小空闲时间 默认1800000毫秒(30分钟) jedisPoolConfig.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis); // 每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3 jedisPoolConfig.setNumTestsPerEvictionRun(numTestsPerEvictionRun); // 逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1 jedisPoolConfig.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis); // 是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个 jedisPoolConfig.setTestOnBorrow(testOnBorrow); // 在空闲时检查有效性, 默认false jedisPoolConfig.setTestWhileIdle(testWhileIdle); return jedisPoolConfig; &#125; @Bean public RedisConnectionFactory redisConnectionFactory(JedisPoolConfig jedisPoolConfig)&#123; RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration(); redisStandaloneConfiguration.setHostName(host); redisStandaloneConfiguration.setPort(port); JedisClientConfiguration.JedisPoolingClientConfigurationBuilder jpcf = (JedisClientConfiguration.JedisPoolingClientConfigurationBuilder) JedisClientConfiguration.builder(); jpcf.poolConfig(jedisPoolConfig); JedisClientConfiguration jedisClientConfiguration = jpcf.build(); return new JedisConnectionFactory(redisStandaloneConfiguration, jedisClientConfiguration); &#125; /** * 实例化 RedisTemplate 对象 * */ @Bean public RedisTemplate&lt;String, Object&gt; functionDomainRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123; RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); initDomainRedisTemplate(redisTemplate, redisConnectionFactory); return redisTemplate; &#125; /** * 设置数据存入 redis 的序列化方式,并开启事务 * * @param redisTemplate * @param factory */ private void initDomainRedisTemplate(RedisTemplate&lt;String, Object&gt; redisTemplate, RedisConnectionFactory factory) &#123; //如果不配置Serializer，那么存储的时候缺省使用String，如果用User类型存储，那么会提示错误User can't cast to String！ redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer()); redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer()); // 开启事务 redisTemplate.setEnableTransactionSupport(true); redisTemplate.setConnectionFactory(factory); &#125; /** * 注入封装RedisTemplate */ @Bean(name = "redisUtils") public RedisUtils redisUtil(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; RedisUtils redisUtils = new RedisUtils(); redisUtils.setRedisTemplate(redisTemplate); return redisUtils; &#125;&#125; RedisUtils.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527package com.bbdog.demo.utils;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.util.CollectionUtils;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;public class RedisUtils &#123; private RedisTemplate&lt;String, Object&gt; redisTemplate; public void setRedisTemplate(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; //=============================common============================ /** * 指定缓存失效时间 * @param key 键 * @param time 时间(秒) * @return */ public boolean expire(String key,long time)&#123; try &#123; if(time&gt;0)&#123; redisTemplate.expire(key, time, TimeUnit.SECONDS); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 根据key 获取过期时间 * @param key 键 不能为null * @return 时间(秒) 返回0代表为永久有效 */ public long getExpire(String key)&#123; return redisTemplate.getExpire(key,TimeUnit.SECONDS); &#125; /** * 判断key是否存在 * @param key 键 * @return true 存在 false不存在 */ public boolean hasKey(String key)&#123; try &#123; return redisTemplate.hasKey(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 删除缓存 * @param key 可以传一个值 或多个 */ @SuppressWarnings("unchecked") public void del(String ... key)&#123; if(key!=null&amp;&amp;key.length&gt;0)&#123; if(key.length==1)&#123; redisTemplate.delete(key[0]); &#125;else&#123; redisTemplate.delete(CollectionUtils.arrayToList(key)); &#125; &#125; &#125; //============================String============================= /** * 普通缓存获取 * @param key 键 * @return 值 */ public Object get(String key)&#123; return key==null?null:redisTemplate.opsForValue().get(key); &#125; /** * 普通缓存放入 * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key,Object value) &#123; try &#123; redisTemplate.opsForValue().set(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 普通缓存放入并设置时间 * @param key 键 * @param value 值 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期 * @return true成功 false 失败 */ public boolean set(String key,Object value,long time)&#123; try &#123; if(time&gt;0)&#123; redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); &#125;else&#123; set(key, value); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 递增 * @param key 键 * @param by 要增加几(大于0) * @return */ public long incr(String key, long delta)&#123; if(delta&lt;0)&#123; throw new RuntimeException("递增因子必须大于0"); &#125; return redisTemplate.opsForValue().increment(key, delta); &#125; /** * 递减 * @param key 键 * @param by 要减少几(小于0) * @return */ public long decr(String key, long delta)&#123; if(delta&lt;0)&#123; throw new RuntimeException("递减因子必须大于0"); &#125; return redisTemplate.opsForValue().increment(key, -delta); &#125; //================================Map================================= /** * HashGet * @param key 键 不能为null * @param item 项 不能为null * @return 值 */ public Object hget(String key,String item)&#123; return redisTemplate.opsForHash().get(key, item); &#125; /** * 获取hashKey对应的所有键值 * @param key 键 * @return 对应的多个键值 */ public Map&lt;Object,Object&gt; hmget(String key)&#123; return redisTemplate.opsForHash().entries(key); &#125; /** * HashSet * @param key 键 * @param map 对应多个键值 * @return true 成功 false 失败 */ public boolean hmset(String key, Map&lt;String,Object&gt; map)&#123; try &#123; redisTemplate.opsForHash().putAll(key, map); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * HashSet 并设置时间 * @param key 键 * @param map 对应多个键值 * @param time 时间(秒) * @return true成功 false失败 */ public boolean hmset(String key, Map&lt;String,Object&gt; map, long time)&#123; try &#123; redisTemplate.opsForHash().putAll(key, map); if(time&gt;0)&#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 向一张hash表中放入数据,如果不存在将创建 * @param key 键 * @param item 项 * @param value 值 * @return true 成功 false失败 */ public boolean hset(String key,String item,Object value) &#123; try &#123; redisTemplate.opsForHash().put(key, item, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 向一张hash表中放入数据,如果不存在将创建 * @param key 键 * @param item 项 * @param value 值 * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间 * @return true 成功 false失败 */ public boolean hset(String key,String item,Object value,long time) &#123; try &#123; redisTemplate.opsForHash().put(key, item, value); if(time&gt;0)&#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 删除hash表中的值 * @param key 键 不能为null * @param item 项 可以使多个 不能为null */ public void hdel(String key, Object... item)&#123; redisTemplate.opsForHash().delete(key,item); &#125; /** * 判断hash表中是否有该项的值 * @param key 键 不能为null * @param item 项 不能为null * @return true 存在 false不存在 */ public boolean hHasKey(String key, String item)&#123; return redisTemplate.opsForHash().hasKey(key, item); &#125; /** * hash递增 如果不存在,就会创建一个 并把新增后的值返回 * @param key 键 * @param item 项 * @param by 要增加几(大于0) * @return */ public double hincr(String key, String item,double by)&#123; return redisTemplate.opsForHash().increment(key, item, by); &#125; /** * hash递减 * @param key 键 * @param item 项 * @param by 要减少记(小于0) * @return */ public double hdecr(String key, String item,double by)&#123; return redisTemplate.opsForHash().increment(key, item,-by); &#125; //============================set============================= /** * 根据key获取Set中的所有值 * @param key 键 * @return */ public Set&lt;Object&gt; sGet(String key)&#123; try &#123; return redisTemplate.opsForSet().members(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 根据value从一个set中查询,是否存在 * @param key 键 * @param value 值 * @return true 存在 false不存在 */ public boolean sHasKey(String key,Object value)&#123; try &#123; return redisTemplate.opsForSet().isMember(key, value); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将数据放入set缓存 * @param key 键 * @param values 值 可以是多个 * @return 成功个数 */ public long sSet(String key, Object...values) &#123; try &#123; return redisTemplate.opsForSet().add(key, values); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 将set数据放入缓存 * @param key 键 * @param time 时间(秒) * @param values 值 可以是多个 * @return 成功个数 */ public long sSetAndTime(String key,long time,Object...values) &#123; try &#123; Long count = redisTemplate.opsForSet().add(key, values); if(time&gt;0) expire(key, time); return count; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 获取set缓存的长度 * @param key 键 * @return */ public long sGetSetSize(String key)&#123; try &#123; return redisTemplate.opsForSet().size(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 移除值为value的 * @param key 键 * @param values 值 可以是多个 * @return 移除的个数 */ public long setRemove(String key, Object ...values) &#123; try &#123; Long count = redisTemplate.opsForSet().remove(key, values); return count; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; //===============================list================================= /** * 获取list缓存的内容 * @param key 键 * @param start 开始 * @param end 结束 0 到 -1代表所有值 * @return */ public List&lt;Object&gt; lGet(String key, long start, long end)&#123; try &#123; return redisTemplate.opsForList().range(key, start, end); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 获取list缓存的长度 * @param key 键 * @return */ public long lGetListSize(String key)&#123; try &#123; return redisTemplate.opsForList().size(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 通过索引 获取list中的值 * @param key 键 * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推 * @return */ public Object lGetIndex(String key,long index)&#123; try &#123; return redisTemplate.opsForList().index(key, index); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 将list放入缓存 * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, Object value) &#123; try &#123; redisTemplate.opsForList().rightPush(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, Object value, long time) &#123; try &#123; redisTemplate.opsForList().rightPush(key, value); if (time &gt; 0) expire(key, time); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, List&lt;Object&gt; value) &#123; try &#123; redisTemplate.opsForList().rightPushAll(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, List&lt;Object&gt; value, long time) &#123; try &#123; redisTemplate.opsForList().rightPushAll(key, value); if (time &gt; 0) expire(key, time); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 根据索引修改list中的某条数据 * @param key 键 * @param index 索引 * @param value 值 * @return */ public boolean lUpdateIndex(String key, long index,Object value) &#123; try &#123; redisTemplate.opsForList().set(key, index, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 移除N个值为value * @param key 键 * @param count 移除多少个 * @param value 值 * @return 移除的个数 */ public long lRemove(String key,long count,Object value) &#123; try &#123; Long remove = redisTemplate.opsForList().remove(key, count, value); return remove; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125;&#125; testController.java 12345678910111213141516171819import com.bbdog.demo.utils.RedisUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping(value = "/test")public class TestDBController &#123; @Autowired private RedisUtils redisUtils; @RequestMapping(value = "/getRedis") public String getRedis()&#123; redisUtils.set("a",1); return redisUtils.get("a").toString(); &#125;&#125; RedisUtils:封装的Redis工具类；RedisUtils底层实际上是由redisTemplate对象操作redis; redisTemplate由RedisConfig.functionDomainRedisTemplate()实例化，并对数据存入进行序列化。 到这里为止Redis学习环境就大功告成了。]]></content>
      <categories>
        <category>springBoot</category>
      </categories>
      <tags>
        <tag>springBoot</tag>
        <tag>redis</tag>
        <tag>Jedis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络-计算机网络基础]]></title>
    <url>%2F2019%2F07%2F08%2F%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[abstract 计算机网络基础之前上学时候感觉网络学的挺透彻，毕业一年细节就忘得差不多，只能想起些专有名词。所以从网络上，教材上搜罗些网络基础来加深记忆。 网络层次划分国际标准化组织(ISO)制定了OSI七层网络模型。从下到上分别是：{(物理层)、(数据链路层)、(网络层)、(传输层)、(会话层、表示层、应用层)} 每一层接受下层服务并为上层提供服务，上三层面向用户。在七层模型基础上又有TCP/IP四、五层模型。 物理层 主要功能：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。 设备：调制调解器、集线器 数据链路层 主要功能：数据成帧，链路接入，流量控制，差错检测等 如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位； 如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配； 以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。 数据链路层在不可靠的物理介质上提供可靠的传输。 设备：网路适配器（网卡）、交换机 网络层 数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。 主要功能：路径选择、路由及逻辑寻址； 主要设备：路由器 主要协议： ARP协议（Address Resolution Protocol，地址解析协议）; IP协议（Internet Protocol，因特网互联协议）; ICMP协议（Internet Control Message Protocol，因特网控制报文协议）; RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。 传输层 根据通信子网的特性，最佳的利用网络资源，为两个端系统中主机到主机之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。 主要功能：传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题； 设备：网关 主要协议： TCP协议（Transmission Control Protocol，传输控制协议） UDP协议（User Datagram Protocol，用户数据报协议） 应用层HTTP协议（Hyper Text Transfer Protocol） 会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。 表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。 为操作系统或网络应用程序提供访问网络服务的接口。 主要协议： FTP（文件传送协议） Telnet（远程登录协议） DNS（域名解析协议） SMTP（邮件传送协议） POP3协议（邮局协议） HTTP协议（Hyper Text Transfer Protocol） 模型中的协议： 传输内容： IP地址IP地址由网络号和主机号组成。分为A、B、C、D、E五类地址；具体划分如下： 除了这五类地址还有一些特殊地址： 网络地址：主机号全0表示当前网络 广播地址：主机号全1表示当前网络广播地址（也称直接广播地址） 0.0.0.0： 255.255.255.255：该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。 注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。 回环地址：127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。 私有地址： A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255 B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255 C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255 子网划分IP/ICMP协议IP协议IP协议是将多个包交换网络连接起来，它在源地址和目的地址之间传送一种称之为数据包的东西，它还提供对数据大小的重新组装功能，以适应不同网络对包大小的要求。 IP不提供可靠的传输服务，它不提供端到端的或（路由）结点到（路由）结点的确认，对数据没有差错控制，它只使用报头的校验码，它不提供重发和流量控制。如果出错可以通过ICMP报告，ICMP在IP模块中实现。 ICMP协议ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。 常用形式有两种：查询报文、控制报文。 查询报文 ​ 查询端获取请求，并获取对方相应。如ping命令 ​ ping命令相当于在原生ICMP报文中增加时间和序号，根据返回相应的顺序和时间来增加准确性。 控制报文 源抑制报文 发送端发送大量数据时，可能会导致网络( 路由器 )过载，此时过载处可以向发送端发送源抑制的消息，让他降低发送速度。 终点不可到达网络信息不能到达终点，就会给发送端发送一个目的不可到达的信息。告诉发送端可能是设备故障而引起关闭（情况之一）。然后这种又可以再次细分：A、网络不可达 — 代码为 0，B、主机不可达 — 代码为 1.C、协议不可达 — 代码为 2.D、端口不可达 — 代码为 3.E、需要分段 - 代码为 4.（ 必须把数据分段才能去到终点 ） 超时网络包超过设置的在网络中的生存时间，还没有达到。 路由重定向 定义数据包的路由股则。因为大部分的时候，路由规则是通过相关协议算法生成的，有些时候重新定义过之后，会让这个数据包绕的更远。 相见本文traceroute命令（windows系统为tracert命令） ARP/RARP协议ARP协议流程地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。 源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。 注意：广播（255.255.255.255）发送ARP请求，单播发送ARP响应。 RARP协议流程RARP协议是根据mac地址获取IP地址的一个协议 发送端发送一个本地的RARP广播包，在此广播包中声明自己的MAC地址，并且请求任何收到此请求的RARP服务器分配一个IP地址。 本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址。如果存在，RARP服务器就给源主机发送一个响应数据包，并将此IP地址提供给对方主机使用；如果不存在，RARP服务器对此不做任何响应。 源端在收到从RARP服务器来的响应信息后，利用得到的IP地址进行通信；如果一直没有收到RARP服务器的响应信息，则表示初始化失败。 路由选择协议上学时学到的路由选择协议有RIP协议、OSPF协议 RIP协议： OSPF协议： TCP/IP协议TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。 歪，你在吗（甲方不知道乙方在不在） 嗯嗯，我在（乙方知道甲方在找自己，乙方不知道甲方能不能接收到回应）【甲方确认乙方】 在那我就开始说了（甲方知道乙方在，并且告诉乙方收到了他的回应）【乙方确认甲方】 双方确认的基础上进行可靠连接。 我听到一个消息，巴拉 嗯嗯，你继续说 巴拉巴拉 嗯嗯，你继续说 巴拉巴拉巴拉 ？？？ 怎么不回了？巴拉巴拉巴拉 连接意外断开情况 为了防止漏掉信息，结束对话更是谨慎 甲：我没有要说的了（停止发送数据） 已： 嗯嗯（我收了你不发信息的通知了）【已方知道甲方不发消息了】 已： 我也没有要说的了（停止发送数据） 甲： 拜拜【甲方也知道乙方不再发消息了】 由此可见，TCP协议是建立在双方完全确认的情况下进行的计算机程序之间的端到端的连接。 UDP协议ip协议是不可靠的，邮局到邮局的传输，UDP则像是对IP协议的接口话，实现了，邮筒到信箱之间的不可靠传输。 ping命令TTL : 数据包在网络中生存时间，也就是通过数据被路由器转发的次数，没转发一次就减一。知道为 0 的时候就抛弃。 windowns系统只会请求4次，linux系统会一直请求。 因为是基础，暂不研究详细参数。 traceroute命令traceoute 有点像是在不断试错的意思,windows系统为tracert命令。是用来侦测主机到目的主机之间所经路由情况的重要工具。Ping 我们知道是可以知道这条大路通不通的，traceoute 通过设置 TTL 知道到底是哪个路由器不通。 traceroute 的原理：它收到目的主机的 IP 后，首先给目的主机发送一个 TTL=1 的 UDP 数据包，而经过的第一个路由器收到这个数据包以后，就自动把 TTL 减 1，而 TTL 变为 0 以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的 ICMP 数据报给主机。如此循环就可以知道所有的路由 IP 了。（ ICMP 出错了就会回错误包 ）通常 Traceoute 的目的端口设置的是一个大于 30000 的值（ 一般的应用端口号远小于这个数 ）。所以如果回复的是 “端口不可达”，那就说明到达终点，否则这个信息就会超时。以此确保 消息是否到达终点。 traceoute 还有一个有意思的功能，就是确定 MTU（数据最大传输单元），traceoute 通常对数据不分段，就直接发送，如果如果遇到过程中某个路由转发，出现返回 ICMP 需要分段的错误，就把数据进行拆分，直到最后到达终点。就验证出 MTU。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie及Session]]></title>
    <url>%2F2019%2F04%2F05%2FCookie%E5%8F%8ASession%2F</url>
    <content type="text"><![CDATA[用户访问服务器，如果要区分不同用户的操作，行为等,比如在登陆是勾选记住我，下次就可以不需要登陆直接访问。区分不同的用户，现在客户端用到最多的就是Cookies和Session.Cookie和Session同样可以用来存储用户标识，但他们的存储地点，生存周期，等有很大的区别，常将两者连用。这里会把基础的特征详细的讲一下，扩展讲一下他们的安全性。为下一篇的单点登陆做铺垫。 Cookie由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。 Cookie是服务器发送给浏览器的特殊信息（需要浏览器支持Cookie），以文本方式存储在本地，一般是存储在[系统盘]:\Documents and Settings[用户名]\Cookies目录. 当浏览器向服务器发送请求时，会在请求头中携带Cookie信息。服务器接收到请求后对Cookie中的信息进行识别，操作。最后和返回信息一起返回来。 Cookie的不可跨域性每个网站都会颁发自己的Cookie,而每个网站只希望浏览器请求的时候带上的是自己颁发的Cookie.Cookie规范中的不可跨域性就保证了每个网站只能接受自己颁发的Cookies,Google接收不到alibaba的Cookie，Alibaba接收不到baidu的Cookie。 编码规则如果是Unicode的字符，需要指定编码，一般使用UTF-8,如果是二进制数据，应该编码应指定为base64，英文默认使用两字节的ASCII编码 Cookie的属性 String name: 该Cookie的名称。Cookie一旦创建，名称便不可更改. Object value：该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码。 int maxAge：该Cookie失效的时间，单位秒。如果为正数，则该Cookie在&gt;maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为–1。(这里有很多坑) boolean secure：该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。 String path：该Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/”。 String domain：可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”。 String comment：该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明。 int version：该Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范。 Cookie的有效期Cookie的maxAge决定着Cookie的有效期，单位为秒（Second）。Cookie中通过getMaxAge()方法与setMaxAge(int maxAge)方法来读写maxAge属性。 如果为正数，则表示该Cookie会在maxAge秒之后自动失效,并会进行持久化，关闭浏览器仍在有效期内。还可以这样设置为永久有效。 123Cookie cookie = new Cookie("username","bbdogUser1"); // 新建Cookiecookie.setMaxAge(Integer.MAX_VALUE); // 设置生命周期为MAX_VALUEresponse.addCookie(cookie); // 输出到客户端 如果maxAge为负数，则表示该Cookie仅在本浏览器窗口以及本窗口打开的子窗口内有效，关闭窗口后该Cookie即失效。maxAge为负数的Cookie，为临时性Cookie，不会被持久化，不会被写到Cookie文件中。Cookie信息保存在浏览器内存中，因此关闭浏览器该Cookie就消失了。Cookie默认的maxAge值为–1。 如果maxAge为0，则表示删除该Cookie。Cookie机制没有提供删除Cookie的方法，因此通过设置该Cookie即时失效实现删除Cookie的效果。失效的Cookie会被浏览器从Cookie文件或者内存中删除： 123Cookie cookie = new Cookie("username","bbdogUser1"); // 新建Cookiecookie.setMaxAge(0); // 设置生命周期为0，不能为负数response.addCookie(cookie); // 必须执行这一句 注意：从客户端读取Cookie时，包括maxAge在内的其他属性都是不可读的，也不会被提交。浏览器提交Cookie时只会提交name与value属性。maxAge属性只被浏览器用来判断Cookie是否过期。 Cookie的添加和删除Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。负数代表其他的意义。读者可以通过上例的程序进行验证，设置不同的属性。 注意：修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。 Cookie的域名Cookie是不可跨域名的。域名www.google.com颁发的Cookie不会被提交到域名www.baidu.com去。这是由Cookie的隐私安全机制决定的。隐私安全机制能够禁止网站非法获取其他网站的Cookie。 正常情况下，同一个一级域名下的两个二级域名如www.bbdog.com和images.bbdog.com也不能交互使用Cookie，因为二者的域名并不严格相同。如果想所有bbdog.com名下的二级域名都可以使用该Cookie，需要设置Cookie的domain参数，例如：12345Cookie cookie = new Cookie("time","20000000"); // 新建Cookiecookie.setDomain(".bbdog.com"); // 设置域名cookie.setPath("/"); // 设置路径cookie.setMaxAge(Integer.MAX_VALUE); // 设置有效期response.addCookie(cookie); // 输出到客户端 读者可以修改本机C:\WINDOWS\system32\drivers\etc下的hosts文件来配置多个临时域名，然后使用setCookie.jsp程序来设置跨域名Cookie验证domain属性。 注意：domain参数必须以点(“.”)开始。另外，name相同但domain不同的两个Cookie是两个不同的Cookie。如果想要两个域名完全不同的网站共有Cookie，可以生成两个Cookie，domain属性分别为两个域名，输出到客户端。 Cookie的路径Cookie的路径是值浏览器访问服务器资源的路径. 那么Cookie的path是干什么的呢？假设你的浏览器当前已经有了两个Cookie： Cookie1：name=id; value=itcast; path=/day07_03/； Cookie2：name=name; value=qdmmy6; path=/day07_03/servlet/。 当访问http://localhost/day07_03/时，请求头中会包含c1，而不会包含c2。 当访问http://localhost/day07_03/servlet/时，请求头中会包含c1和c2。 注意： 如果服务器相应的时候没有特意设置路径，则会默认返回。例如在请求http://localhost/day07_03/AServlet时，服务器响应了一个Cookie，那么这个Cookie的默认路径就是/day07_03/。 Cookie的安全性HTTP协议不仅是无状态的，而且是不安全的。使用HTTP协议的数据不经过任何加密就直接在网络上传播，有被截获的可能。使用HTTP协议传输很机密的内容是一种隐患。如果不希望Cookie在HTTP等非安全协议中传输，可以设置Cookie的secure属性为true。浏览器只会在HTTPS和SSL等安全协议中传输此类Cookie。下面的代码设置secure属性为true： 123Cookie cookie = new Cookie("time", "20000000"); // 新建Cookiecookie.setSecure(true); // 设置安全属性response.addCookie(cookie); // 输出到客户端 提示：secure属性并不能对Cookie内容加密，因而不能保证绝对的安全性。如果需要高安全性，需要在程序中对Cookie内容加密、解密，以防泄密。 SessionSession可以理解为会话的意思，会话可以理解为客户端与服务器的信息交流.Cookie是将客户信息储存在客户端本地，而Session则是将客户信息存储在服务器。通过Cookie识别了用户身份，再通过Cookie中记录的SessionId来获取用户的身份明细。Session保存在服务器端，因为使用频繁，早期常将直接保存在内存中，但用户量过大时，存储压力增大，还有可能造成内存溢出。现在常将其保存在高读写的数据库中，如redis，并根据实际情况进行分布式处理。 Session生命周期Session在用户第一次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session。如果尚未生成Session，也可以使用request.getSession(true)强制生成Session。 Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃（active）”了一次。 Session的有效期由于会有越来越多的用户访问服务器，因此Session也会越来越多。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。 Session的超时时间为maxInactiveInterval属性，可以通过对应的getMaxInactiveInterval()获取，通过setMaxInactiveInterval(longinterval)修改。 Session的超时时间也可以在web.xml中修改。另外，通过调用Session的invalidate()方法可以使Session失效。 Session的常用方法Session中包括各种方法，使用起来要比Cookie方便得多。Session的常用方法如下所示。 void setAttribute(String attribute, Object value)：设置Session属性。value参数可以为任何Java Object。通常为Java Bean。value信息不宜过大 String getAttribute(String attribute)：返回Session属性 Enumeration getAttributeNames()：返回Session中存在的属性名 void removeAttribute(String attribute)：移除Session属性 String getId()：返回Session的ID。该ID由服务器自动创建，不会重复 long getCreationTime()：返回Session的创建日期。返回类型为long，常被转化为Date类型，例如：Date createTime = new Date(session.get &gt;CreationTime()) long getLastAccessedTime()：返回Session的最后活跃时间。返回类型为long int getMaxInactiveInterval()：返回Session的超时时间。单位为秒。超过该时间没有访问，服务器认为该Session失效 void setMaxInactiveInterval(int second)：设置Session的超时时间。单位为秒。 void putValue(String attribute, Object value)：不推荐的方法。已经被setAttribute(String attribute, Object Value)替代 Object getValue(String attribute)：不被推荐的方法。已经被getAttribute(String attr)替代 boolean isNew()：返回该Session是否是新创建的 void invalidate()：使该Session失效 Session生存时间设置Tomcat中设置的默认时间时20分钟，可以在web.xml中修改。单位为分钟123&lt;session-config&gt; &lt;session-timeout&gt;60&lt;/session-timeout&gt; &lt;!-- 单位：分钟 --&gt;&lt;/session-config&gt; 也可以通过setMaxInactiveInterval(int seconds)方法修改。单位为秒 session对浏览器的支持支持cookie因为sessionId记在cookie中，所以使用的时候相对简单。但是需要注意的是，新打开tab页签的时候，共用的当前浏览器窗口的session。但是新打开浏览器窗口的时候，就会新建session. 不支持Cookie如果浏览器不支持cookie,就要使用其他方法来解决。常见的方法有URL重写，和页面重定向。HttpServletResponse类提供了encodeURL(Stringurl)实现URL地址重写。1&lt;a href="&lt;%=response.encodeURL("index.jsp?c=1&amp;wd=Java") %&gt;"&gt;Homepage&lt;/a&gt; 该方法会自动判断客户端是否支持Cookie。如果客户端支持Cookie，会将URL原封不动地输出来。如果客户端不支持Cookie，则会将用户Session的id重写到URL中。重写后的输出可能是这样的： 1&lt;a href="index.jsp;jsessionid=0CCD096E7F8D97B0BE608AFDC3E1931E?c=1&amp;wd=Java"&gt;Homepage&lt;/a&gt; 即在文件名的后面，在URL参数的前面添加了字符串“;jsessionid=XXX”。其中XXX为Session的id。分析一下可以知道，增添的jsessionid字符串既不会影响请求的文件名，也不会影响提交的地址栏参数。用户单击这个链接的时候会把Session的id通过URL提交到服务器上，服务器通过解析URL地址获得Session的id。页面重定向可通过如下实现：1234if(“administrator”.equals(userName)) &#123; response.sendRedirect(response.encodeRedirectURL(“administrator.jsp”)); return;&#125; 与encodeURL方法类似，他也会先进行cookie支持检测。 注意：TOMCAT判断客户端浏览器是否支持Cookie的依据是请求中是否含有Cookie。尽管客户端可能会支持Cookie，但是由于第一次请求时不会携带任何Cookie（因为并无任何Cookie可以携带），URL地址重写后的地址中仍然会带有jsessionid。当第二次访问时服务器已经在浏览器中写入Cookie了，因此URL地址重写后的地址中就不会带有jsessionid了。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
        <tag>会话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven-使用Nexus搭建私服]]></title>
    <url>%2F2019%2F03%2F08%2Fmaven-%E4%BD%BF%E7%94%A8Nexus%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%8D%2F</url>
    <content type="text"><![CDATA[abstract 下载官方下载地址 安装选择合适的位置解压压缩包 这就是Nexus的主要安装目录 当然也可以安装成服务 安装失败，归其原因是因为命令行权限不够，应该使用管理员角色启动命令行 配置主要的几个配置文件路径 nexus-3.15.2-01-win64\nexus-3.15.2-01\bin\nexus.vmoptions nexus-3.15.2-01-win64\nexus-3.15.2-01\etc\nexus-default.properties 例如修改nexus-default.properties中的启动端口1application-port=8686 ##启动 浏览器输入你配置的地址查看Nexus首页]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>Nexus</tag>
        <tag>私服</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis-缓存]]></title>
    <url>%2F2019%2F03%2F01%2FMybatis-%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[abstract 缓存的作用对于变动不频繁的数据，我们通常使用缓存的方式来将数据存起来，从而减少程序对数据库的访问次数，提升查找效率。 Mybatis一级缓存一级缓存是Sqlsession级别的。默认开启。一个Sqlsession对象代表一次数据库会话。一次会话中有可能频繁执行相同查询语句，往往结果短时间内不会变动，对于这种不会变动的数据。Sqlsession会把每次查询的结果放在本地缓存(local cache)，当发现相同查询时，直接从本地缓存中取。减少了对数据库的io和数据库的查询。 Mybatis一级缓存相关接口类SqlSession将它的工作交给了Executor执行器这个角色来完成，负责完成对数据库的各种操作。缓存信息也由Executor执行器维护。 MyBatis将缓存和对缓存相关的操作封装成了Cache接口中。SqlSession、Executor、Cache之间的关系如下列类图所示： BaseExecutor类实现了Executor接口 PerpetualCache类实现了Cache接口 BaseExecutor类的queryFromDatabase等方法可以操纵PerpetualCache类。从而实现了对缓存的操控。 PerpetualCache实现原理其实很简单，其内部就是通过一个简单的HashMap&lt;k,v&gt; 来实现的，没有其他的任何限制。如下是PerpetualCache的实现代码： MyBatis一级缓存工作流程 对于某个查询，根据statementId,params,rowBounds等来构建一个key值，根据这个key值去缓存Cache中取出对应的key值存储的缓存结果； 判断从Cache中根据特定的key值取的数据数据是否为空，即是否命中； 如果命中，则直接将缓存结果返回； 如果没命中： 去数据库中查询数据，得到查询结果； 将key和查询到的结果分别作为key,value对存储到Cache中； 将查询结果返回； 如何判断两次查询是相同的呢结论 判断[statementId + rowBounds + 传递给JDBC的SQL + 传递给JDBC的参数值]组成的CacheKey是否相同。 判断依据 传入的statementId，对于MyBatis而言，你要使用它，必须需要一个statementId，它代表着你将执行什么样的Sql； MyBatis自身提供的分页功能是通过RowBounds来实现的，它通过rowBounds.offset和rowBounds.limit来过滤查询出来的结果集，这种分页功能是基于查询结果的再过滤，而不是进行数据库的物理分页； 由于MyBatis底层还是依赖于JDBC实现的，那么，对于两次完全一模一样的查询，MyBatis要保证对于底层JDBC而言，也是完全一致的查询才行。而对于JDBC而言，两次查询，只要传入给JDBC的SQL语句完全一致，传入的参数也完全一致，就认为是两次查询是完全一致的。 上述的第3个条件正是要求保证传递给JDBC的SQL语句完全一致；第4条则是保证传递给JDBC的参数也完全一致；MyBatis会将上述的SQL中的#{} 转化成？，通过JDBC的PreparedStatement的参数值进行替换，如果参数值相同，则满足自四条Mybatis一级缓存的生命周期生成 随Sqlsession的创建而创建 消亡 SqlSession的close()方法会释放缓存,缓存不可用 SqlSession的clearCache()方法会清空缓存中的内容 SqlSession执行update()、delete()、insert()方法时，会清空缓存中的内容 Mybatis一级缓存注意事项对于数据更新频繁的SQL,应该注意Sqlsession的生存时间，或是再mapper文件中禁用一级缓存 Mybatis一级缓存扩展PerpetualCache类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* * Copyright 2009-2012 The MyBatis Team * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.ibatis.cache.impl;import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;import org.apache.ibatis.cache.Cache;import org.apache.ibatis.cache.CacheException;public class PerpetualCache implements Cache &#123; private String id; private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;(); private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); public PerpetualCache(String id) &#123; this.id = id; &#125; public String getId() &#123; return id; &#125; public int getSize() &#123; return cache.size(); &#125; public void putObject(Object key, Object value) &#123; cache.put(key, value); &#125; public Object getObject(Object key) &#123; return cache.get(key); &#125; public Object removeObject(Object key) &#123; return cache.remove(key); &#125; public void clear() &#123; cache.clear(); &#125; public ReadWriteLock getReadWriteLock() &#123; return readWriteLock; &#125; public boolean equals(Object o) &#123; if (getId() == null) throw new CacheException("Cache instances require an ID."); if (this == o) return true; if (!(o instanceof Cache)) return false; Cache otherCache = (Cache) o; return getId().equals(otherCache.getId()); &#125; public int hashCode() &#123; if (getId() == null) throw new CacheException("Cache instances require an ID."); return getId().hashCode(); &#125;&#125; BaseExecutor类的queryFromDatabase方法 1234567891011121314private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; List&lt;E&gt; list; localCache.putObject(key, EXECUTION_PLACEHOLDER); try &#123; list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql); &#125; finally &#123; localCache.removeObject(key); &#125; localCache.putObject(key, list); if (ms.getStatementType() == StatementType.CALLABLE) &#123; localOutputParameterCache.putObject(key, parameter); &#125; return list;&#125; Mybatis二级缓存二级缓存是mapper级别的。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库-多表关联]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%A4%9A%E8%A1%A8%E5%85%B3%E8%81%94%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git-常用操作]]></title>
    <url>%2F2019%2F01%2F28%2FGit-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[abstract 设置用户信息设置用户名、邮箱全局通用用户信息，本机上所有的Git仓库都是使用这个账号。123git config --global user.name "userName"git config --global user.email "userEmail" 也可以针对某个仓库指定用户名和邮箱 仓库相关初始化仓库使用初始化仓库命令可以在一个打算作为仓库的目录中生成一个.git目录，这个目录就是用作版本控制的文件目录。 1git init 将文件从工作区添加到暂存区1git add 文件名 查看文件提交状态1git status 这个命令会比对仓库与暂存区文件差异，并将差异展现出来。 查看差异1git diff 文件名 将会展现Unix中diff差异格式。 将文件从暂存区提交到仓库1git commit -m "更新说明" 1git commit -a -m "更新说明" 加上-a参数会执行 add + commit 命令 查看版本1git log 默认按更新日期从近到远展示三次提交记录。展示信息如下： commit 最近一次版本号 Author: 用户名&lt;邮箱&gt; Date: 日期 更新说明 commit 上上次版本号 Author: 用户名&lt;邮箱&gt; Date: 日期 更新说明 也可以展示简略信息1git log –-pretty=oneline 展示信息如下： 版本号 更新说明 版本号 更新说明 版本号 更新说明 跳转到某一个版本1234567git reset --hard HEAD^``` 跳转到上一次，`HEAD^^`,挑战到上上次。`HEAD^^^`跳转到上上上次。那么问题来了，上一百次怎么复制粘贴最合理？但其实并不需要```bashgit reset --hard HEAD~100 回退之后后悔了怎么办。git log 也看不到版本号了鸭，这个时候操作1git reflog]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaIO-File中常用方法]]></title>
    <url>%2F2019%2F01%2F25%2FJavaIO-File%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[abstract ## 示例123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args)&#123; String fileName = "D:" + File.separator + "Files"; File file = new File(fileName); // 判断路径指向的文件/文件夹是否存在、是否目录 if (file.exists() &amp;&amp; file.isDirectory())&#123; System.out.println("file是一个文件夹\n"); File[] files = file.listFiles(); // 获取目录下的所有文件/文件夹（仅该层路径下） System.out.print("路径下有文件："); for (File f : files) &#123; System.out.print(f + "\t"); &#125; //信息 System.out.println("files[0]的文件名：" + files[0].getName()); // 获取文件名、文件夹名 System.out.println("files[0]的文件路径：" + files[0].getPath()); // 获取文件、文件夹路径 System.out.println("files[0]的绝对路径：" + files[0].getAbsolutePath()); // 获取文件、文件夹绝对路径 System.out.println("files[0]的父文件夹名：" + files[0].getParent()); // 获取文件父目录路径 System.out.println("files[0]的最后修改时间：" + files[0].lastModified()); // 获取文件、文件夹上一次修改时间 System.out.println("files[0]的大小：" + files[0].length() + " Bytes"); // 获取文件的字节数，如果是一个文件夹则这个值为0 System.out.println("files[0]的路径转换为URI：" + files[0].toURI()); // 获取文件路径URI后的路径名 //状态 System.out.println(files[0].exists() ? "files[0]的存在" : "files[0]的不存在"); // 判断文件、文件夹是否存在 System.out.println(files[0].canWrite() ? "files[0]的可写" : "files[0]的不可写"); // 判断文件是否可写 System.out.println(files[0].canRead() ? "files[0]的可读" : "files[0]的不可读"); // 判断文件是否可读 System.out.println(files[0].canExecute() ? "file[0]可执行" : "file[0]不可执行"); // 判断文件是否可执行 System.out.println(files[0].isDirectory() ? "files[0]的是目录" : "files[0]的不是目录"); // 判断文件、文件夹是不是目录 System.out.println(files[0].isFile() ? "files[0]的是文件" : "files[0]的不是文件"); // 判断拿文件、文件夹是不是标准文件 System.out.println(files[0].isAbsolute() ? "files[0]的路径名是绝对路径" : "files[0]的路径名不是绝对路径"); // 判断路径名是不是绝对路径 //操作 if (files[0].exists()) files[0].delete(); // 删除指定的文件、文件夹 if (files[1].exists()) files[1].deleteOnExit(); // 当虚拟机终止时删除指定的文件、文件夹 &#125;&#125; 输出结果： file是一个文件夹 路径下有文件：D:\Files\BBDog.txt files[0]的文件名：BBDog.txt files[0]的文件路径：D:\Files\BBDog.txt files[0]的绝对路径：D:\Files\BBDog.txt files[0]的父文件夹名：D:\Files files[0]的存在 files[0]的可写 files[0]的可读 file[0]可执行 files[0]的不是目录 files[0]的是文件 files[0]的路径名是绝对路径 files[0]的最后修改时间：1548408240577 files[0]的大小：6 Bytes files[0]的路径转换为URI：file:/D:/Files/BBDog.txt 说明指定文件名时推荐使用File.separator,来实现跨平台目录分隔符-程序会判断系统类型从而展现不同的分隔符。 删除操作必须目录下没有目录或文件]]></content>
      <categories>
        <category>Java IO</category>
      </categories>
      <tags>
        <tag>File</tag>
        <tag>文件流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尝试-尝试实现扫二维码登陆]]></title>
    <url>%2F2019%2F01%2F24%2F%E5%B0%9D%E8%AF%95-%E5%B0%9D%E8%AF%95%E5%AE%9E%E7%8E%B0%E6%89%AB%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[TODO 方式一生成二维码要想二维码唯一，用于生成二维码的 长地址转短地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.util.LinkedList;import java.util.List;import org.apache.http.NameValuePair;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;/*** * 短链接转换工具类 * * @author Administrator * */public class ShortUrlHelper &#123; public static CloseableHttpClient httpClient; static &#123; httpClient = HttpClients.createDefault(); &#125; /** * 将长链接转为短链接(调用的新浪的短网址API) * * @param url * 需要转换的长链接url * @return 返回转换后的短链接 */ public static String convertSinaShortUrl(String url) &#123; try &#123; // 调用新浪API HttpPost post = new HttpPost("http://api.t.sina.com.cn/short_url/shorten.json"); List&lt;NameValuePair&gt; params = new LinkedList&lt;NameValuePair&gt;(); // 必要的url长链接参数 params.add(new BasicNameValuePair("url_long", url)); // 必要的新浪key params.add(new BasicNameValuePair("source", "3271760578")); post.setEntity(new UrlEncodedFormEntity(params, "UTF-8")); CloseableHttpResponse response = httpClient.execute(post); // 得到调用新浪API后成功返回的json字符串 // url_short : 短链接地址 type：类型 url_long：原始长链接地址 String json = EntityUtils.toString(response.getEntity(), "utf-8"); JSONArray jsonArray = JSONArray.parseArray(json); JSONObject object = (JSONObject) jsonArray.get(0); return object.getString("url_short"); &#125; catch (Exception e) &#123; e.printStackTrace(); return ""; &#125; &#125; /** * 将长链接转为短链接(调用的百度短网址API) * * @param url * 需要转换的长链接url * @return 返回转换后的短链接 */ public static String convertBaiDuShortUrl(String url) &#123; try &#123; // 调用百度API HttpPost post = new HttpPost("http://www.dwz.cn/create.php"); List&lt;NameValuePair&gt; params = new LinkedList&lt;NameValuePair&gt;(); // 必要的url长链接参数 params.add(new BasicNameValuePair("url", url)); post.setEntity(new UrlEncodedFormEntity(params, "UTF-8")); CloseableHttpResponse response = httpClient.execute(post); // 得到调用百度API后成功返回的json字符串 // tinyurl : 短链接地址 status：0 表示转换成功 非0表示转换失败 longurl：原始长链接地址 err_msg:错误信息 String jsonStr = EntityUtils.toString(response.getEntity(), "utf-8"); JSONObject object = JSON.parseObject(jsonStr); return object.getString("tinyurl"); &#125; catch (Exception e) &#123; e.printStackTrace(); return ""; &#125; &#125; /** * 测试 * @param args */ public static void main(String []args)&#123; String tinyurl = convertBaiDuShortUrl("http://news.sina.com.cn/gov/xlxw/2018-09-05/doc-ihiixyeu3395739.shtml"); System.out.println(tinyurl); &#125;&#125; 轮询判断二维码状态（服务器请求压力） 未扫描 扫描成功 过时刷新 扫码uid绑定用户(额外库)稍后轮询会返回扫描成功 点击登陆方式二生成二维码扫码通知后台进行登陆 推送 未扫码，不推送 扫码成功，用户信息页 点击登陆]]></content>
      <categories>
        <category>尝试</category>
      </categories>
      <tags>
        <tag>二维码</tag>
        <tag>登陆</tag>
        <tag>短地址</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[规范-特殊注释]]></title>
    <url>%2F2019%2F01%2F23%2F%E8%A7%84%E8%8C%83-%E7%89%B9%E6%AE%8A%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[1TODO:这里将要放一个华丽又不失内涵的简介 特殊注释 TODO: 标识该处有功能代码待编写，待实现的功能在说明中会简略说明。 FIXME: 标识该处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。 XXX: 标识该处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>TODO</tag>
        <tag>XXX</tag>
        <tag>FIXME</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用方法-集合工具类常用方法]]></title>
    <url>%2F2019%2F01%2F23%2FJava%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[真香~ 对象List按属性排序1234567891011121314151617181920212223242526272829303132333435363738394041class Animal&#123; private String kind; private int quantity; public Animal(String k,int q)&#123; this.kind = k; this.quantity = q; &#125;&#125;public class Main&#123; public static void main(String[] args) &#123; Animal dog = new Animal("狗",10000); Animal cat = new Animal("猫",5000); Animal pig = new Animal("猪",2000); List&lt;Animal&gt; animalList = new ArrayList&lt;Animal&gt;(); animalList.add(dog); animalList.add(cat); animalList.add(pig); Collections.sort(animalList, new Comparator&lt;TestA&gt;() &#123; @Override public int compare(TestA o1, TestA o2) &#123; //升序 return o1.getAge().compareTo(o2.getAge()); &#125; &#125;); Collections.sort(animalList, new Comparator&lt;TestA&gt;() &#123; @Override public int compare(TestA o1, TestA o2) &#123; //降序 return o1.getAge().compareTo(o2.getAge()); &#125; &#125;); &#125;&#125; List初始化时进行赋值1List&lt;Long&gt; ids = Arrays.asList(98765432109L,12345678901L);]]></content>
      <categories>
        <category>Java常用方法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>List</tag>
        <tag>对象</tag>
        <tag>属性</tag>
        <tag>初始化</tag>
        <tag>赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-Java常用关键字]]></title>
    <url>%2F2019%2F01%2F16%2FJava%E5%9F%BA%E7%A1%80-Java%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[abstract final修饰类被final修饰的类不能被继承 修饰方法 “使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。” 由此可见，被final修饰的方法最主要的目的就是防止方法被重写 修饰变量对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 对象的引用无法改变，但是对象的属性值可不可以改变呢？ 因为payStatus是int类型，初始化时候会给定默认值：0 此时输出结果 1 10 从结果来看，final”锁定”的是对象的引用，并没有”锁定”属性的值； 注意事项final与static的区别,static作用于成员变量用来表示只保存一份副本，而final的作用是用来保证变量不可变。 示例：123456789101112131415final class Father&#123; public final Double i = Math.random(); public static Double j = Math.random();&#125;public static void main(String[] args)&#123; Father f = new Father(); Father ff = new Father(); System.out.println(f.i); System.out.println(f.j); System.out.println(); System.out.println(ff.i); System.out.println(ff.j);&#125; 输出结果： 0.41791403026319096 0.8147697161273327 0.9571817275395188 0.8147697161273327 参考资料博客园-海子-浅析Java中的final关键字 博客园-五月的仓颉-谈谈final的作用 static 静态方法内部不能调用非静态方法，非静态方法没有此限制。 被static修饰的变量属于类变量，可以通过类名.变量名直接引用，而不需要new出一个类来 被static修饰的方法属于类方法，可以通过类名.方法名直接引用，而不需要new出一个类来 静态资源是类初始化的时候加载的，类实例之间共享，一处变，处处变。 并且被static修饰的方法是没有this的，他不依附于任何对象。但是非静态方法是依赖于具体对象而调用的。这就是为什么静态方法内部不能调用非静态方法。 既然静态资源不依赖于任何对象，那为什么还要放在不同对象里呢。是不是可以把所有静态资源全都放到一起? 避免重名，通过不同对象使同名静态资源区分开。 资源分类清晰，功能明确。 放到一起，那存放静态资源的这个类会特别大。 静态资源（变量/方法/代码块）static变量也称作静态变量，静态变量和非静态变量的区别是： 静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。 很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。 注意事项静态资源真的没有this吗？ 1234567891011121314151617final class Father&#123; static int wg = 31; public void pringtWg()&#123; int wg = 13; System.out.println(this.wg); &#125;&#125;public class TestExcel &#123; public static void main(String[] args) throws Exception &#123; new Father().pringtWg(); &#125;&#125; 输出： 31 this是指当前对象，printWg中的wg是局部变量，无法与this内联。 常见面试题一1234567891011121314151617181920212223242526public class Son extends Father&#123; static&#123; System.out.println("son static"); &#125; public Test()&#123; System.out.println("son constructor"); &#125; public static void main(String[] args) &#123; System.out.println("main()"); new Son(); &#125;&#125;class Father&#123; static&#123; System.out.println("father static"); &#125; public Base()&#123; System.out.println("father constructor"); &#125;&#125; 输出： father static son static main() father constructor son constructor 程序执行顺序： main()作为程序入口； 需要加载Son,发现Son继承Father，加载Father; Father中有static块，初始化加载这个static块； 返回Son,Son中有static块，初始化这个static块； 打印输出字符串”main()” 执行new Son(); Son继承Father，Father有构造函数，执行构造函数； 返回Son,Son有构造函数，执行构造函数； 第2~4步是对象的加载过程，第5~7步是对象的执行过程；输出结果与执行顺序的对应关系 输出行 对应执行顺序 father static 3 son static 4 father constructor 7 son constructor 8 不难发现即使mian()中并没有语句，但仍然会有输出。就像之前所说，jvm会把所有不在方法内部的的静态资源初始化。 参考资料博客园-海子-浅析Java中的final关键字 博客园-五月的仓颉-谈谈final的作用 包和访问权限控制关键字package 包是可以理解为命名空间，他能有效解决类重名问题。 为了方便组织和管理，多用倒置域名来标识。 默认访问权限（包访问权限）、public、private和protected一个.java文件只能有一个被public修饰的类，并且类名必须与文件名相同。如果没有public关键字，则对类的命名没有要求。 修饰类 默认访问权限（包访问权限）：用来修饰类的话，表示该类只对同一个包中的其他类可见。 public：用来修饰类的话，表示该类对其他所有的类都可见。 如果你想实现其他任何人都不能访问该类，可以通过将类的所有构造器都指定为private。1234567891011121314151617package com.qigou.b2cex.test;class People &#123; private String name = null; public People(String name) &#123; this.name = name; &#125; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125;&#125; 1234567package com.qigou.b2cex.test;public class TestExcel&#123; public static void main(String[] args) throws Exception &#123; System.out.println(new People("BBDog").getName()); &#125;&#125; 输出结果： BBDog 将People的包名改为test1后 修饰方法和变量 作用域 当前类 同包下 子孙 所有类 public √ √ √ √ protected √ √ √ × 默认 √ √ × × private √ × × × 1234567891011121314151617package com.qigou.b2cex.test;public class People &#123; private String name = null; public People(String name) &#123; this.name = name; &#125; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125;&#125; 12345678package com.qigou.b2cex.test;public class TestExcel&#123; public static void main(String[] args) throws Exception &#123; People people = new People("BBDog"); System.out.println(people.getName()); &#125;&#125; 变更getName()的权限,每次初始化包名。 public 正常输出： BBDog 默认 同包下正常输出： BBDog 修改People包名为test1 protected 同包下正常输出： BBDog 修改People包名为test1 创建Kids类继承People 12345678910111213package com.qigou.b2cex.test;import com.qigou.b2cex.test1.People;public class Kids extends People &#123; public Kids(String name)&#123; super(name); &#125; public String toString() &#123; return getName(); &#125;&#125; 子类拥有权限，但是调用子类仍然不被允许 private 参考资料 博客园-海子-浅析Java中的final关键字]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>关键字</tag>
        <tag>final</tag>
        <tag>static</tag>
        <tag>package</tag>
        <tag>访问控制</tag>
        <tag>public</tag>
        <tag>private</tag>
        <tag>protected</tag>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElasticSearch单机集群搭建与ElasticHD]]></title>
    <url>%2F2019%2F01%2F11%2F%E6%A1%86%E6%9E%B6-ElasticSearch%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E4%B8%8EElasticHD%2F</url>
    <content type="text"><![CDATA[abstract 本机环境操作系统及位数 下载ES及分词器选择用户为什么要把选择用户单独列一项，因为ElasticSearch无法在ROOT下启动。所以，安装、配置、创建所需目录也都提前到选择用户之后。 安装##]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
        <tag>ES</tag>
        <tag>ElasticHD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[equals()和hashCode()]]></title>
    <url>%2F2019%2F01%2F07%2FJava%E5%9F%BA%E7%A1%80-equals%E5%92%8ChashCode%2F</url>
    <content type="text"><![CDATA[原生equals()底层源码通过==来实现，比较的是两个对象（两个对象的引用地址）。 hashCode()是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值. 两个对象的equals()相等（原生），hashCode()一定相等； 两个对象hashCode()相等，epuals()并不一定相等。 equals() 原生equals()底层源码通过==来实现，比较的是两个对象（两个对象的引用地址）。 重写equals()用来比较两个对象的内容是否相等。 常用覆盖逻辑12345678910111213141516171819202122/** * @desc 覆盖equals方法 */ public boolean equals(Object obj)&#123; if(obj == null)&#123; return false; &#125; //如果是同一个对象返回true，反之返回false if(this == obj)&#123; return true; &#125; //判断是否类型相同 if(this.getClass() != obj.getClass())&#123; return false; &#125; //比较对象属性值是否相等 //例如 Person中有两个属性 name,age Person person = (Person)obj; return name.equals(person.name) &amp;&amp; age==person.age; &#125; hashCode()hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值.对象的地址或者字符串或者数字就是keys，通过一个函数算出hash. hashCode=F(key); hashCode() 在散列表中才有用，在其它情况下没用。在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置； 两个对象的equals()相等（原生），hashCode()一定相等； 两个对象hashCode()相等，epuals()并不一定相等。 我们应该根据对象的特点，重写hashCode方法，尽量避免（3）提到的哈希冲突情况。 HashSet判定一个对象是否重复： HashSet判定为重复对象。 未重写equals()和hashCode()时: code: 123456789Person p1 = new Person("aaa",1);Person p2 = p1;Person p3 = new Person("bbb",1);Set&lt;Person&gt; PS = Sets.newHashSet();PS.add(p1);PS.add(p2);PS.add(p3);System.out.println(p1.equals(p2));System.out.printf(PS+"====》"+"p1.hashCode(%s)==&gt;p2.hashCode(%s)==&gt;p3.hashCode(%s)",p1.hashCode(),p2.hashCode(),p3.hashCode()); console： 12true[aaa - 1, bbb - 1]====》p1.hashCode(1047503754)==&gt;p2.hashCode(1047503754)==&gt;p3.hashCode(1722023916) 我们知道原生equals()相等时，hashCode一定相等； code: 123456789Person p1 = new Person("aaa",1);Person p2 = new Person("aaa",1);Person p3 = new Person("bbb",1);Set&lt;Person&gt; PS = Sets.newHashSet();PS.add(p1);PS.add(p2);PS.add(p3);System.out.println(p1.equals(p2));System.out.printf(PS+"====》"+"p1.hashCode(%s)==&gt;p2.hashCode(%s)==&gt;p3.hashCode(%s)",p1.hashCode(),p2.hashCode(),p3.hashCode()); console： 12false[bbb - 1, aaa - 1, aaa - 1]====》p1.hashCode(1047503754)==&gt;p2.hashCode(1722023916)==&gt;p3.hashCode(2009787198) 只重写hashCode()时： code: 123456789101112131415161718private static class Person &#123; @Override public int hashCode()&#123; int nameHash = name.toUpperCase().hashCode(); return nameHash ^ age; &#125;&#125;public static void main(String[] args)&#123; Person p1 = new Person("aaa",1); Person p2 = new Person("aaa",1); Person p3 = new Person("bbb",1); Set&lt;Person&gt; PS = Sets.newHashSet(); PS.add(p1); PS.add(p2); PS.add(p3); System.out.println(p1.equals(p2)); System.out.printf(PS+"====》"+"p1.hashCode(%s)==&gt;p2.hashCode(%s)==&gt;p3.hashCode(%s)",p1.hashCode(),p2.hashCode(),p3.hashCode()); &#125; console: 12false[aaa - 1, aaa - 1, bbb - 1]====》p1.hashCode(64544)==&gt;p2.hashCode(64544)==&gt;p3.hashCode(65539) 只重写equals()时： code: 123456789101112131415161718192021222324252627282930313233private static class Person &#123; @Override public boolean equals(Object obj)&#123; if(obj == null)&#123; return false; &#125; //如果是同一个对象返回true，反之返回false if(this == obj)&#123; return true; &#125; //判断是否类型相同 if(this.getClass() != obj.getClass())&#123; return false; &#125; Person person = (Person)obj; return name.equals(person.name) &amp;&amp; age==person.age; &#125;&#125;public static void main(String[] args)&#123; Person p1 = new Person("aaa",1); Person p2 = new Person("aaa",1); Person p3 = new Person("bbb",1); Set&lt;Person&gt; PS = Sets.newHashSet(); PS.add(p1); PS.add(p2); PS.add(p3); System.out.println(p1.equals(p2)); System.out.printf(PS+"====》"+"p1.hashCode(%s)==&gt;p2.hashCode(%s)==&gt;p3.hashCode(%s)",p1.hashCode(),p2.hashCode(),p3.hashCode()); &#125; console: 12true[bbb - 1, aaa - 1, aaa - 1]====》p1.hashCode(1047503754)==&gt;p2.hashCode(1722023916)==&gt;p3.hashCode(2009787198) 同时重写equals()和hashCode()时： code: 1234567891011public static void main(String[] args)&#123; Person p1 = new Person("aaa",1); Person p2 = new Person("aaa",1); Person p3 = new Person("bbb",1); Set&lt;Person&gt; PS = Sets.newHashSet(); PS.add(p1); PS.add(p2); PS.add(p3); System.out.println(p1.equals(p2)); System.out.printf(PS+"====》"+"p1.hashCode(%s)==&gt;p2.hashCode(%s)==&gt;p3.hashCode(%s)",p1.hashCode(),p2.hashCode(),p3.hashCode()); &#125; console: 12true[aaa - 1, bbb - 1]====》p1.hashCode(64544)==&gt;p2.hashCode(64544)==&gt;p3.hashCode(65539) 至此我们推断HashSet的判重逻辑是，hashCode()与equals()同时满足]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>equals</tag>
        <tag>hashCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习-内存模型]]></title>
    <url>%2F2019%2F01%2F05%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Xmind Zen 挺好用的 学习了《深入理解Java虚拟机》–周志明之后的一点点个人总结，如有错误还请指正。 文字版如下 运行时内存线程私有虚拟机栈 描述 java方法执行的内存模型 存储局部变量表、操作数栈、动态链接、方法出口等信息 方法开始执行时，创建栈帧 从方法执行到执行完成对应（一个栈帧）入栈出栈的过程 功能 局部变量表 存放该方法调用者所传入的参数，及在该方法的方法体中创建的局部变量。 对象引用(reference类型) 可能是指向对象起始地址的引用指针 也可能是指向一个代表对象的句柄 returnAddress类型 指向一条字节码指令的地址 多线程 生命周期与线程一致 抛出异常 线程请求深度大于虚拟机栈允许最大深度时 StackOverflowError 虚拟机栈可以动态扩展，无法申请到足够内存 OutOfMemoryError 本地方法栈 描述 与虚拟机栈十分相似 只不过针对Native方法服务 功能 多线程 生命周期与线程一致 抛出异常 同虚拟机栈异常 程序计数器 描述 当前线程所执行字节码的行号指示器 功能 字节码解释器改变计数器的值 如果执行的是native方法，则计数器值为空 多线程 每个线程的计数器互不影响，相互独立 jvm多线程的理解 jvm通过轮流分配处理器执行时间，实现多线程 共享区域java堆 描述 虚拟机启动时创建 功能 存放对象的实例 jit编译器与逃逸分析技术的发展，栈上分配、标量替换使这一条不那么绝对 存放数组 为了更好的分配和回收会进行细分、功能不变 新生代和老年代 Eden空间、From Survivor空间、To Survivor空间 线程私有的分配缓冲区 TLAB GC 内存回收的主要区域 抛出异常 堆中没有内存可以完成实力分配并且没法扩展时 OutOfMemoryError 参数 -Xmx -Xms 方法区 主区域 描述 堆的逻辑区域 功能 存储已被虚拟机加载的类信息 类的版本、字段、方法、接口等描述信息 常量池 常量 静态变量 即时编辑器编译后的代码 特点 不需要连续的内存空间 可固定可扩展 可以不实现垃圾回收（垃圾回收在此区相对较少） 参数 有些虚拟机把分代收集扩展到方法区称为永久代 永久代大小 -XX:MaxPermSize 运行时常量池 描述 用于存放编译期生成的各种字面变量和符号引用 功能 还可以保存翻译出来的直接引用 特点 相对于Class文件常量池具备动态性 运行期间也可以讲新的常量放入池中 String.intern() 抛出异常 方法区无法满足内存分配需求时 OutOfMemoryError 直接内存 描述 NIO类可以操作Native函数库直接分配堆外内存 通过存储在堆中的DirectByteBuffer对象作为这块内存引用操作 抛出异常 OutOfMemoryError 参数 主动设置 -XX:maxDirectMemorySize 默认 -Xms 对象对象的创建 类加载 先通过New指令的参数去常量池中定位到一个类的符号引用 编译时并不知道一个类的直接内存地址，只能使用（符号）来标识类的地址 如果没有，执行相应的类加载过程 分配内存空间 类加载完成后所需的大小可以完全确定 将所需的内存区域从Java堆中划分出来 内存分配方式 规整的内存（已用和未用有一个区分界限） 零散的区域 需要一个空闲列表来统计空闲区域 内存分配时并发性问题 描述 正在给A对象分配，指针还没来得及移动，要开始分配B对象，使用了A对象内存区域 解决方案 动作原子性控制 CAS配上失败重试 作用域控制 为每个线程在堆中分配TLAB,每个线程在自己的区域中划分内存 如果原来的缓冲区域用完了，需要新的缓冲区来划分内存，则需要同步锁来保证完整性 启用TLAB -XX:+/-UseTLAB 翻台 将分配的内存区域置零 不包括对象头 如果使用TLAB，这一步在TLAB分配时完成 设置 根据对象头 对象是那个类的实例 如何才能找到类的元数据信息 对象的哈希码 对象的GC分代年龄等 至此一个对象创建完成，但是对于Java程序来讲对象的创建才刚刚开始，接下来执行init方法 对象的内存布局 对象头包含两部分信息 运行时数据、信息 位数固定 如果储存的信息太多时会复用位数空间 类型指针 即指向它类元数据的指针 虚拟机通过这个指针来确定对象是哪个类的实例 真正储存的有效信息 各类型字段（包括父类） 存储顺序 虚拟机分配策略参数 相同宽度的字段总是被分配到一起 父类定义的变量会在子类之前 字段在Java源码中的定义顺序 对齐填充 保证地址空间时8字节的整数倍 对象的访问定位 通过栈上的reference数据来操作对象 指向对象的引用 访问方式 句柄 Java堆中划分出一块句柄池 reference存储句柄地址 句柄包含对象实例数据与类型数据各自的具体信息 直接指针 Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息 优缺点 直接指针访问速度快，对象移动时需要改变栈中reference 句柄每次访问查一遍句柄池，但是对象移动（垃圾收集时）不需要修改栈中reference]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>虚拟机</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习JVM前的准备]]></title>
    <url>%2F2019%2F01%2F05%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AD%A6%E4%B9%A0JVM%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[一个java程序的分娩过程 一个java程序的分娩过程大致可以分为一下四步 生成.java文件此处不必多说，但需要注意语法 生成.class文件使用Javac命令可将.java文件编译成.class文件 使用java -v [.class文件名]查看字节码文件使用java -v [.class文件名] &gt; [输出文件路径]将字节码文件输出到指定路径的文件中java的跨平台性就体现在无论以何种方式生成字节码文件，只要字节码文件符合规范。jvm都能运行此处推荐一个.class文件查看器github:jclasslib 类加载器加载.class文件 类加载器会通过CLASSPATH找到需要执行的.class文件 读取字节码文件流，储存在方法区中3.执行引擎找到main()作为入口图片来自百度百科]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
        <tag>字节码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis-generator]]></title>
    <url>%2F2018%2F11%2F23%2F%E5%B7%A5%E5%85%B7-mybatis-generator%2F</url>
    <content type="text"><![CDATA[abstract 添加依赖1234567891011&lt;!-- mybatis generator 自动生成代码插件 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; 编辑配置文件在&lt;configurationFile&gt;指向的位置添加generatorConfig.xml文件当前目录123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt; &lt;classPathEntry location="D:\bbgog\bbdog-maven\maven-repository\org\mariadb\jdbc\mariadb-java-client\2.3.0\mariadb-java-client-2.3.0.jar"/&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass="org.mariadb.jdbc.Driver" connectionURL="jdbc:mariadb://localhost:3306/test" userId="root" password="123456"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置--&gt; &lt;javaModelGenerator targetPackage="com.demo.entity" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件的包名和位置--&gt; &lt;sqlMapGenerator targetPackage="mapping" targetProject="src/main/resources"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成mapper的包名和位置--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.demo.mapper" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt; &lt;table tableName="user" domainObjectName="User" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 启动generator在指定位置新建需求表123456CREATE TABLE USER ( user_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, user_name VARCHAR ( 255 ) NOT NULL, PASSWORD VARCHAR ( 255 ) NOT NULL, phone VARCHAR ( 255 ) NOT NULL) ENGINE = INNODB AUTO_INCREMENT = 1000 DEFAULT CHARSET = utf8; 双击启动generator 生成后项目目录 生成对应POJO类 生成对应mapper 生成对应mapper.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.demo.mapper.UserMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.demo.entity.User" &gt; &lt;id column="user_id" property="userId" jdbcType="INTEGER" /&gt; &lt;result column="user_name" property="userName" jdbcType="VARCHAR" /&gt; &lt;result column="password" property="password" jdbcType="VARCHAR" /&gt; &lt;result column="phone" property="phone" jdbcType="VARCHAR" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; user_id, user_name, password, phone &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from user where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from user where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.demo.entity.User" &gt; insert into user (user_id, user_name, password, phone) values (#&#123;userId,jdbcType=INTEGER&#125;, #&#123;userName,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, #&#123;phone,jdbcType=VARCHAR&#125;) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.demo.entity.User" &gt; insert into user &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="userId != null" &gt; user_id, &lt;/if&gt; &lt;if test="userName != null" &gt; user_name, &lt;/if&gt; &lt;if test="password != null" &gt; password, &lt;/if&gt; &lt;if test="phone != null" &gt; phone, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="userId != null" &gt; #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="userName != null" &gt; #&#123;userName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null" &gt; #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.demo.entity.User" &gt; update user &lt;set &gt; &lt;if test="userName != null" &gt; user_name = #&#123;userName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; password = #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null" &gt; phone = #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/set&gt; where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.demo.entity.User" &gt; update user set user_name = #&#123;userName,jdbcType=VARCHAR&#125;, password = #&#123;password,jdbcType=VARCHAR&#125;, phone = #&#123;phone,jdbcType=VARCHAR&#125; where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/update&gt;&lt;/mapper&gt;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>generator</tag>
        <tag>逆向生成文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4j补充]]></title>
    <url>%2F2018%2F11%2F23%2F%E6%A1%86%E6%9E%B6-Log4j%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[Log4j补充 LoggerConfig LevelEvent Level和LoggerConfig Level对照表 Event Level LoggerConfig Level LoggerConfig Level LoggerConfig Level LoggerConfig Level LoggerConfig Level LoggerConfig Level LoggerConfig Level Event Level TRACE DEBUG INFO WARN ERROR FATAL OFF ALL YES YES YES YES YES YES NO TRACE YES NO NO NO NO NO NO DEBUG YES YES NO NO NO NO NO INFO YES YES YES NO NO NO NO WARN YES YES YES YES NO NO NO ERROR YES YES YES YES YES NO NO FATAL YES YES YES YES YES YES NO OFF NO NO NO NO NO NO NO 感谢大佬翻译了APILog4j输出格式控制–log4j的PatternLayout参数含义以及详细配置 官方API 没把格式化看懂，但是意外发现了一个markdown编辑神器，可以把excel表格转为Markdown表格。详见文章【利器】 参数 说明 例子 %c 列出logger名字空间的全称，如果加上{&lt;层数&gt;}表示列出从最内层算起的指定层数的名字空间 log4j配置文件参数举例 输出显示媒介 假设当前logger名字空间是”a.b.c” %c a.b.c %c{2} b.c %20c （若名字空间长度小于20，则左边用空格填充） %-20c （若名字空间长度小于20，则右边用空格填充） %.30c （若名字空间长度超过30，截去多余字符） %20.30c （若名字空间长度小于20，则左边用空格填充；若名字空间长度超过30，截去多余字符） %-20.30c （若名字空间长度小于20，则右边用空格填充；若名字空间长度超过30，截去多余字符） %C 列出调用logger的类的全名（包含包路径） 假设当前类是”org.apache.xyz.SomeClass” %C org.apache.xyz.SomeClass %C{1} SomeClass %d 显示日志记录时间，{&lt;日期格式&gt;}使用ISO8601定义的日期格式 %d{yyyy/MM/dd HH:mm:ss,SSS} 2005/10/12 22:23:30,117 %d{ABSOLUTE} 22:23:30,117 %d{DATE} 12 Oct 2005 22:23:30,117 %d{ISO8601} 2005-10-12 22:23:30,117 %F 显示调用logger的源文件名 %F MyClass.java %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数 %l MyClass.main(MyClass.java:129) %L 显示调用logger的代码行 %L 129 %m 显示输出消息 %m This is a message for debug. %M 显示调用logger的方法名 %M main %n 当前平台下的换行符 %n Windows平台下表示rn UNIX平台下表示n %p 显示该条日志的优先级 %p INFO %r 显示从程序启动时到记录该条日志时已经经过的毫秒数 %r 1215 %t 输出产生该日志事件的线程名 %t MyClass %x 按NDC（Nested Diagnostic Context，线程堆栈）顺序输出日志 假设某程序调用顺序是MyApp调用com.foo.Bar %c %x - %m%n MyApp - Call com.foo.Bar. com.foo.Bar - Log in BarMyApp - Return to MyApp. %X 按MDC（Mapped Diagnostic Context，线程映射表）输出日志。通常用于多个客户端连接同一台服务器，方便服务器区分是那个客户端访问留下来的日志。 %X{5} （记录代号为5的客户端的日志） %% 显示一个百分号 %% %]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>log4j</tag>
        <tag>补充</tag>
        <tag>log4j格式化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利器]]></title>
    <url>%2F2018%2F11%2F23%2F%E5%B7%A5%E5%85%B7-%E5%88%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[这是你的金斧子吗？这是你的银斧子吗？ 编辑器markdownExcel表格转Markdown表格官网高大上，功能很强大，未深喑其中功能但觉得安装包不小。Typora官网]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4j]]></title>
    <url>%2F2018%2F11%2F23%2F%E6%A1%86%E6%9E%B6-Log4j%2F</url>
    <content type="text"><![CDATA[abstract 添加依赖在pom.xml文件中添加如下依赖12345678910111213141516171819&lt;!-- spring boot start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!-- 排除自带的logback依赖 --&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- springboot-log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt; &lt;version&gt;1.3.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 编辑配置文件rootloggerrootlogger主要定义log4j支持的日志级别及输出目的地，其语法为：1log4j.rootLogger = [ level ] , appenderName, appenderName, … level 是日志记录的优先级，分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别。 appenderName指定日志信息输出到哪个地方，可同时指定多个输出目的地。 例如: 1log4j.rootLogger=info, stdout 有两个疑惑： Level 代号 FATAL 0 ERROR 3 WARN 4 INFO 6 DEBUG 7 后面Threshold有限制输出范围，如果这里设置了ERROR,Threshold设置INfO,日志会输出WARN,和INFO级别的日志信息吗？ 中间丢失的1、2、5对应什么级别，他们是被弃用了吗？我这里有酒，希望有了解的可以讲出他们的故事； appenderappender附加器主要定义日志信息输出位置，输出格式等。主要语法为： 123log4j.appender.appenderName = classInfolog4j.appender.appenderName.option1 = value1log4j.appender.appenderName.optionN = valueN 这里的appenderName与rootlogger中的appenderName对应 appender的classInfo有如下选项： org.apache.log4j.ConsoleAppender（控制台） org.apache.log4j.FileAppender（文件） org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件） org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件） org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） 例如: 1log4j.appender.stdout=org.apache.log4j.ConsoleAppender appender.option–FileFile是日志输出的目的地。 例如：1log4j.appender.stdout.File=logs/log.log appender.option–Threshold输出等级限制，包含本身及以上。 例如：12## 输出DEBUG级别以上的日志log4j.appender.stdout.Threshold=DEBUG appender.option–Append日志信息的追加方式。true意味着，默认为truefales意味着， 12345678910111213141516171819package com.qigou.b2cex.test;import com.b2bex.goods.service.EsOrderIndexManager;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.ArrayList;public class TestExcel&#123; private static final Logger logger = LoggerFactory.getLogger("BBDOG"); public static void main(String[] args) throws Exception &#123; logger.info("logger----Info"); logger.warn("logger----warn"); logger.debug("logger----debug"); logger.error("logger----error"); logger.info("-----------------------------分割线-----------------------------"); &#125;&#125; 使用默认配置，配置文件中有如下信息： 再次执行，信息如下； 配置中增加 1log4j.appender.bbdog.Append=fales 再次执行后，本想顺理成章的像其他博文一样展示只有一份信息。但学东西真的这么顺利过吗？ 实际上控制台给我报错： 1log4j:WARN Failed to set property [append] to value "fales". 然后发现呵呵呵呵！false写成了fales.修改后文件中确实只有最新的日志信息了： appender.option–Encoding日志信息的编码格式； 12## 输出DEBUG级别以上的日志log4j.appender.stdout.Encoding=UTF-8 appender.option–DatePattern在DailyRollingFileAppender中可以指定monthly(每月)、 weekly(每周)、daily(每天)、half-daily(每半天)、hourly(每小时)和minutely(每分钟)六个日志生成频度，这是通过为 DatePattern选项赋予不同的值来完成的。DatePattern选项的有效值为： ‘.’yyyy-MM,对应monthly(每月) ‘.’yyyy-ww,对应weekly(每周) ‘.’yyyy-MM-dd,对应daily(每天) ‘.’yyyy-MM-dd-a,对应half-daily(每半天) ‘.’yyyy-MM-dd-HH,对应hourly(每小时) ‘.’yyyy-MM-dd-HH-mm,对应minutely(每分钟) DatePattern中不用处理的文字要放到单引号(‘)中，如上面的(.)。如果您对此有疑问可以查阅SimpleDateFormat的文档。DailyRollingFileAppender中使用这个类来处理DatePattern。 DatePattern格式化之后的文本作为文件名字的后缀。DailyRollingFileAppender不支持格式化之后的文本作为文件名字的前缀。 修改系统时间可以看到效果，当天的文件名为bbdog.log,之前的文件名会加上频度日期 appender.option–LayoutLayout 负责格式化Appender的输出。 Log4j提供的layout有以下几种： org.apache.log4j.HTMLLayout（以HTML表格形式布局）， org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串） org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） 例如： 12log4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %5p %c&#123;1&#125;:%L - %m%n 其中ConversionPattern有如下解释 参数 含义 %m 输出代码中指定的消息 %p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL %r 输出自应用启动到输出该log信息耗费的毫秒数 %c 输出所属的类目，通常就是所在类的全名 %t 输出产生该日志事件的线程名 %n 输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n” %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss , SSS}，输出类似：2002年10月18日 22 ： 10 ： 28 ， 921 %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: 10 ) 这里只演示了DailyRollingFileAppender这种方式下的一些参数. 其他输出类型会有额外的参数，如RollingFileAppender下会有MaxFileSize和MaxBackupIndex,单个文件大小和备份数量 食用方法参考资料博客园-盖世圣猪-log4j配置详解(非常详细) CSDN-谁动了我的bug-Log4j Append属性指定是否追加内容 ConversionPattern中的格式化参数详见Log4j补充]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>Log4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web.xml]]></title>
    <url>%2F2018%2F10%2F25%2F%E8%A7%84%E8%8C%83-web-xml%2F</url>
    <content type="text"><![CDATA[什么是web.xml?在一个web项目中，往往需要一些初始化配置信息，如Welcome页面、servlet、servlet-mapping、filter、listener、启动加载级别等。web.xml文件就是用来初始化这些配置信息。但不是所有的web项目都需要web.xml文件，如果配置不是很负责，可以将他们放到Application中。 ##web.xmlweb.xml也遵循Schema配置的规则，以&lt;web-app&gt;为根标签。文件配置信息为: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; #指定Web应用的大图标和小图标 &lt;icon&gt; &lt;small-icon&gt;/images/app_small.gif&lt;/small-icon&gt; &lt;large-icon&gt;/images/app_large.gif&lt;/large-icon&gt; &lt;/icon&gt; #Web应用的名称 &lt;display-name&gt;Tomcat Example&lt;/display-name&gt; #给出于此相关的说明性文本 &lt;disciption&gt;Tomcat Example servlets and JSP pages.&lt;/disciption&gt; &lt;context-param&gt; &lt;param-name&gt;ContextParameter&lt;/para-name&gt; &lt;param-value&gt;test&lt;/param-value&gt; &lt;description&gt;It is a test parameter.&lt;/description&gt; &lt;/context-param&gt; &lt;!-- 过滤器配置 --&gt; &lt;filter&gt; &lt;filter-name&gt;setCharacterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;com.myTest.setCharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;setCharacterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 监听器 --&gt; &lt;listener&gt; &lt;listerner-class&gt;com.listener.SessionListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;servlet名称&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet类全路径&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;参数名&lt;/param-name&gt; &lt;param-value&gt;参数值&lt;/param-value&gt; &lt;/init-param&gt; &lt;run-as&gt; &lt;description&gt;匿名访问的角色&lt;/description&gt; &lt;role-name&gt;tomcat&lt;/role-name&gt; &lt;/run-as&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;servelet名称&lt;/servlet-name&gt; &lt;url-pattern&gt;映射路径&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- session超时时间（单位：分钟）--&gt; &lt;session-config&gt; &lt;session-timeout&gt;120&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;!-- mime --&gt; &lt;mime-mapping&gt; &lt;extension&gt;htm&lt;/extension&gt; &lt;mime-type&gt;text/html&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;!-- 欢迎页 --&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 错误代码跳转页 --&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/NotFound.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.NullException&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;jsp-config&gt; &lt;taglib&gt; &lt;taglib-uri&gt;Taglib&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/tlds/MyTaglib.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;jsp-property-group&gt; &lt;description&gt;Special property group for JSP Configuration JSP example.&lt;/description&gt; &lt;display-name&gt;JSPConfiguration&lt;/display-name&gt; &lt;url-pattern&gt;/jsp/* &lt;/url-pattern&gt; &lt;el-ignored&gt;true&lt;/el-ignored&gt; &lt;page-encoding&gt;GB2312&lt;/page-encoding&gt; &lt;scripting-invalid&gt;true&lt;/scripting-invalid&gt; &lt;include-prelude&gt;/include/prelude.jspf&lt;/include-prelude&gt; &lt;include-coda&gt;/include/coda.jspf&lt;/include-coda&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>web.xml</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Red-Black Tree]]></title>
    <url>%2F2018%2F10%2F23%2F%E7%AE%97%E6%B3%95-Red-Black-Tree%2F</url>
    <content type="text"><![CDATA[你必须非常努力,才能看起来毫不费力 ———TreeMap 查找查找几乎是现在每时每刻都在用的东西，查找的速度决定了发展的速度。常用查找如： 顺序查找 二分查找 插值查找 斐波那契查找 树查找 分块查找 哈希查找 二叉树查找算法思想：为了查找的方便和快捷，先把待查找的数据生成一棵二叉排序树，利用排序树进行查找 二叉排序树有几个性值： 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树。 二叉查找树性质：对二叉查找树进行中序遍历(左根右)，即可得到有序的数列。 时间复杂度分析： 最优的情况是一个我们构建出一个完全二叉树,时间复杂度与二分查找相同,即树的高度，为O(logn)。 最坏情况是构造出一个单支树,时间复杂度为O(n); 所以，想享受O(logn)的时间复杂度的代价就是，花大功夫构造出一个便于查找的二叉树树。 2-3查找树2-3节点有下列三种可能： 节点为空节点 节点为2节点，2节点中有一个key,有两个2-3节点。左子所有key比2节点的key都小，右子所有key比2节点的key都大。 节点为3节点，3节点中有两个key,有三个2-3节点，左子所有key比3节点小的key都小，中子所有key都介于3节点两个key之间,右子所有key比3节点大的key都大。 2-3查找树特性： 在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。 时间复杂度分析： 最坏情况是所有节点都是2节点，回归二叉树，而且二叉树最优情况完全二叉树，时间复杂度为O(log2n); 最好情况是所有节点都是3节点，时间复杂度就是O(log3n),约等于O(0.631log2n)。 红黑树红黑树是2-3查找树最简单的一种实现。红黑树特性： 每个节点或者是黑色，或者是红色。根节点是黑色。 每个叶子节点（为空的）都是黑色。 红色节点的子节点都是黑色 一个节点到每个子孙节点（叶子节点），经过的黑色节点数都是相同的。 为什么说红黑树是2-3树的简单实现呢。把每个节点看作是2节点。规定红色节点与左子的链接为红色链接。红色链接连接的两个节点看做是一个3节点,就转化成了2-3查找树 TreeMap源码解析（基于jdk1.7）TreeMap是红黑树的实现,首先来看一下TreeMap的Entry 123456K key;V value;Entry&lt;K,V&gt; left = null;Entry&lt;K,V&gt; right = null;Entry&lt;K,V&gt; parent;boolean color = BLACK; 与树的Entry相比多了一个颜色标志位 color。 TreeMap的常用操作 get() put() remove() get()因为TreeMap是已经平衡过的树（因为每次对树的解构进行改动的时候都会重新调整一遍树的机构使其每次使用时都保持最佳状态，映照开头第一句话），所以get()操作就是对排序树的遍历查找，与根节点比较，从而判断下一步走向。如此循环，直至找到对应Entry，或者没有找到而结束。 get()方法调用getEntry方法实现遍历查找12345678910111213141516171819final Entry&lt;K,V&gt; getEntry(Object key) &#123; // Offload comparator-based version for sake of performance if (comparator != null) return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; &#125; return null; &#125; Offload comparator-based version for sake of performance(为了性能，卸载基于比较器的版本) put()put()方法则是先进行一遍get操作，通过K比较，将新Entry放在合适位置，如果是普通二叉树，插入操作到这里就结束了，但是这是红黑树。需要对数的结构进行负责。所以在找到合适位置，插入新Entry之后又对红黑树进行了整体调整。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; if (t == null) &#123; compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; else &#123; if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); rotateLeft(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); rotateRight(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); &#125; &#125; &#125; root.color = BLACK; &#125; remove()remove()方法同样是需要先调用getEntry找到要删除的元素，然后调用deleteEntry删除该元素，删除元素之后同样需要再次对红黑树进行解构调整。 123456789public V remove(Object key) &#123; Entry&lt;K,V&gt; p = getEntry(key); if (p == null) return null; V oldValue = p.value; deleteEntry(p); return oldValue; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; size--; // If strictly internal, copy successor's element to p and then make p // point to successor. if (p.left != null &amp;&amp; p.right != null) &#123; Entry&lt;K,V&gt; s = successor(p); p.key = s.key; p.value = s.value; p = s; &#125; // p has 2 children // Start fixup at replacement node, if it exists. Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123; // Link replacement to parent replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; // Null out links so they are OK to use by fixAfterDeletion. p.left = p.right = p.parent = null; // Fix replacement if (p.color == BLACK) fixAfterDeletion(replacement); &#125; else if (p.parent == null) &#123; // return if we are the only node. root = null; &#125; else &#123; // No children. Use self as phantom replacement and unlink. if (p.color == BLACK) fixAfterDeletion(p); if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; if (x == leftOf(parentOf(x))) &#123; Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateLeft(parentOf(x)); sib = rightOf(parentOf(x)); &#125; if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); setColor(sib, RED); rotateRight(sib); sib = rightOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(rightOf(sib), BLACK); rotateLeft(parentOf(x)); x = root; &#125; &#125; else &#123; // symmetric Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateRight(parentOf(x)); sib = leftOf(parentOf(x)); &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); setColor(sib, RED); rotateLeft(sib); sib = leftOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(leftOf(sib), BLACK); rotateRight(parentOf(x)); x = root; &#125; &#125; &#125; setColor(x, BLACK); &#125; 总结一下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>查找</tag>
        <tag>二叉树</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuffer和StringBuilder]]></title>
    <url>%2F2018%2F10%2F16%2FJava%E5%9F%BA%E7%A1%80-String-StringBuffer-StringBuilder%2F</url>
    <content type="text"><![CDATA[整理一下近期学习的String、StringBuffer和StringBuilder之间的区别 执行速度：String &lt; StringBuffer &lt; Stringbuilder String与StringBuffer和StringBuilder之间的区别 String:字符串常量 StringBuffer:字符串变量 StringBuilder:字符串变量 我们知道String是常量，常量是不可以修改的。123456789101112131415public static void main(String[] args)&#123; String str = "123"; change(str); System.out.println(str);&#125;public static void change(String s)&#123; System.out.println(s); s = s + "abc"; system.out.println(s);&#125;/*console:123123abc123*/ 可以看到change方法并没有起到效果。 调用change方法时，str和s都指向”123” 当执行s = s + &quot;abc&quot;时s指向了”123abc” ，str还是指向”123” 123String s = "123";s = s + "abc";System.out.print(s); //result : 123abc 既然是常量，那为什么这里还可以对常量进行操作呢？JVM会创建一个新的字符串常量，原来的字符串常量成为垃圾被GC回收掉。StringBuffer和StringBuilder是字符串变量，对他们的操作是在原对象上进行的操作。 所以执行速度：String &lt; StringBuffer &lt; Stringbuilder 特例12String Str = "123" + "abc" + "123abc";StringBuffer Strb = new StringBuffer("123").append("abc").append("123abc"); 上面两个字符串生成的速度并不像预期的那样，StringBuffer 快于 String。为什么？因为JVM在创建字符串常量时123String Str = "123" + "abc" + "123abc";//就等于String Str = "123abc123abc"; 所以直接被创建出来，速度很快。但是如果分步执行，就会按照JVM对常规字符串常量的操作，创建新常量，回收旧常量的方式进行操作。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>StringBuffer</tag>
        <tag>StringBuilder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven]]></title>
    <url>%2F2018%2F10%2F12%2F%E6%A1%86%E6%9E%B6-maven%2F</url>
    <content type="text"><![CDATA[abstract pom.XMLmaven坐标Maven坐标元素包括 groupId、artifactId、version、packaging、classifier.groupId：定义当前Maven项目隶属的实际项目。artifactId: 定义实际项目中的一个Maven模块。version: 定义Maven项目当前所处的版本。packaging: 定义Maven项目的打包方式。classifier: 帮助定义构件输出的一些附属构件。 传递性依赖首先我们要了解什么叫直接依赖，A依赖于B，B就是A的直接依赖。A-&gt;B，B-&gt;(C,D)。C、D都是A的传递性依赖。 我们在使用A的时候只需要指出他的直接依赖，maven会自动帮我们解析出我们所需要的间接依赖，而不会引入多余的包。 如果间接依赖引用了同一个项目，但版本不同时，maven解析有两个优先原则： 深度策略。A-&gt;B-&gt;C(1.0) A-&gt;C(2.0)。此时导入C(2.0) FCFS策略。A-&gt;B-&gt;C(1.0) A-&gt;B-&gt;C(2.0)。此时导入C(1.0) 排除依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;3.2.7&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;apache-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 引入了rocketmq,但是不想引入rocketmq里面的apache-lang就可以用exclusions元素进行排除。 排除的时候只需要定位groupId和artifactId就可以确定这个依赖。 setting.XMLlocalRepository本地仓库路径默认值为:$ {user.home} /.m2 / repository1&lt;localRepository&gt;D:/Program Files/Apache/maven-repository&lt;/localRepository&gt; interactiveModeMaven是否应该尝试与用户进行交互以进行输入。默认为:true usePluginRegistryMaven是否单独使用plugin-registry.xml文件来管理插件版本默认值为:false offline设置maven是否应该在全离线模式下运行。默认值为:false proxiesproxies表示maven的代理123456789101112&lt;proxies&gt; &lt;proxy&gt; &lt;id&gt;optional&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;username&gt;proxyuser&lt;/username&gt; &lt;password&gt;proxypass&lt;/password&gt; &lt;host&gt;proxy.host.net&lt;/host&gt; &lt;port&gt;80&lt;/port&gt; &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt; &lt;/proxy&gt;&lt;/proxies&gt; proxies下可以设置多个proxy，使用ID进行唯一标识区分。 id: 每个代理的唯一标识. active: 代理的激活状态，默认值为:true。设置多个代理时，使用第一个active为true的代理。 protocol: 代理使用的协议。默认值为:http username: 代理需要认证时的用户名。 password: 代理需要认证时的密码。 host: 主机名 port: 端口号,默认值为:8080 nonProxyHosts: 表示指定哪些主机名不需要代理，可以用”|” 分隔多个主机名，也支持通配符”*“; server用于连接远程仓库时的安全认证123456789101112&lt;servers&gt; &lt;server&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;username&gt;deployment&lt;/username&gt; &lt;password&gt;deployment&lt;/password&gt; &lt;privateKey&gt;$&#123;usr.home&#125;/.ssh/id_dsa&lt;/privateKey&gt; &lt;passphrase&gt;some_passphrase&lt;/passphrase&gt; &lt;filePermissions&gt;664&lt;/filePermissions&gt; &lt;directoryPermissions&gt;775&lt;/directoryPermissions&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/server&gt;&lt;/serves&gt; id: id是最关键的，这个id必须与需要认证的repository元素的id完全一致才行，换句话说，正式这个id将认证信息和仓库配置联系在了一起。 username: 用户名 password: 密码 privateKey: 鉴权时使用的私钥位置 passphrase: 鉴权时使用的私钥密码。 filePermissions: 文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。 directoryPermissions: 目录被创建时的权限 configuration: 传输层额外的配置项 mirrors仓库的镜像12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;all repository mirror&lt;/name&gt; &lt;url&gt;http://172.16.21.3:8081/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; id,name,url与仓库的配置相同 id: 仓库的唯一标识。 name: 仓库名 url: 仓库的地址.http://maven.net.cn/content/groups/public/ 是 中央仓库 http://repo1.maven.org/maven2/ 在中国的镜像。 mirrorOf：*表示任何对中央仓库的请求都会被转到镜像仓库中。profile个性配置文件，可以通过不同的方式激活。激活条件全部满足时激活该配置文件 1234567891011121314151617181920&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;activation&gt; ··· &lt;/activation&gt; &lt;repositories&gt; &lt;repository&gt; ··· &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; ··· &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; id: 配置文件的唯一标识 activation: 激活方式 repositories: 依赖仓库 pluginRepositories: 插件仓库 activation123456789101112131415161718&lt;activation&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;jdk&gt;1.6&lt;/jdk&gt; &lt;os&gt; &lt;name&gt;Windows 7&lt;/name&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;property&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;file&gt; &lt;exists&gt;$&#123;basedir&#125;/file2.properties&lt;/exists&gt; &lt;missing&gt;$&#123;basedir&#125;/file1.properties&lt;/missing&gt; &lt;/file&gt;&lt;/activation&gt; activeByDefault: 当设置为true时，没有其他profile激活时，自动激活。 jdk: 当JDK版本满足时激活，可以用开闭区间表示一个JDK满足的范围。 os: 当操作系统满足时激活 name: 操作系统 family: 操作系统类型 arch: 操作系统位数 version: 操作系统版本 property: 键值对的形式,当只存在name时。hello属性存在,即可激活。当name，value都存在时，hello属性存在，并且hello属性的value为world时可以激活。 name: hello value: world file: 表示当文件存在或不存在的时候激活 exists: 该路径上的文件存在时激活 missing: 该路径上的文件不存在时激活 repository123456789101112131415161718&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;codehausSnapshots&lt;/id&gt; &lt;name&gt;Codehaus Snapshots&lt;/name&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;never&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;fail&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;url&gt;http://snapshots.maven.codehaus.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt;&lt;/repositories&gt; repositories中可以有多个repository,使用ID进行唯一标识区分。 id: 每个中央仓库的唯一标识。Maven自带的中央仓库使用的id为central，如果其他仓库声明也用该id，就会覆盖中央仓库的配置。 name: 仓库名 url: 中央仓库的地址。 releases: 表示开启仓库的发布版本下载支持。 enabled: 启用状态。默认值为:true。 updatePolicy: 更新时间，可选值有(always、daily、interval:minutes和never) always: 始终 daily: 每天 interval:minutes: 指定时间间隔(单位为分钟) never: 从不 checksumPolicy: 当Maven在部署项目到仓库的时候会连同校验文件一起提交，checksumPolicy表示当这个校验文件缺失或不正确的时候该如何处理，可选项有ignore、fail和warn。 ignore: 忽略 fail: 失败 warn: 警告 snapshots: 表示关闭仓库的快照版本下载支持。参数与releases类似 pluginRepository插件仓库与依赖仓库配置类似12345678910111213&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;http://central&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt; activeProfiles手动激活的构建配置文件列表，按照应用顺序指定。1234&lt;activeProfiles&gt; &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt; &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;&lt;/activeProfiles&gt; 上述配置表示激活所有。 pluginGroups插件组123&lt;pluginGroups&gt; &lt;pluginGroup&gt;org.mortbay.jetty&lt;/pluginGroup&gt;&lt;/pluginGroups&gt; 添加了上面的插件后就可以使用 1mvn jetty:run]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memchahed介绍]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%A1%86%E6%9E%B6-memchahed%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[abstract 我们先抛出几个问题。 什么是缓存？为什么要有缓存？有哪些缓存技术以及他们的优缺点？]]></content>
      <categories>
        <category>框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[javaScript]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%89%8D%E7%AB%AF-javaScript%2F</url>
    <content type="text"><![CDATA[abstract 字符串操作substring截取字符串(“有始无终”) var s = &quot;abcd&quot;; s.substring(1,3); -&gt; &quot;bc&quot; $.trim()$.trim() 函数用于去除字符串两端的空白字符。 var s = &quot; 123 123 456 &quot; $.trim(s); -&gt; &quot;123 123 456&quot; AJAX一、$.ajax()该方法是 jQuery 底层 AJAX 实现。 1、async类型：Boolean 默认值: true。 默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。两条并列AJAX要区分先后顺序的话应采取同步 2、cache类型：Boolean 默认值: true。 dataType 为 script 和 jsonp 时默认为 false。设置为 false 将不缓存此页面。 3、contentType类型：String 默认值: “application/x-www-form-urlencoded”。 请求发送信息至服务器时内容编码类型。默认值适合大多数情况。如果你明确地传递了一个content-type给 $.ajax() 那么它必定会以设定类型发送给服务器（即使没有数据要发送）。 4、success类型：Function 请求成功后的回调函数。 参数：由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串。 这是一个 Ajax 事件。 5、error类型：Function 默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。 有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。 如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是 “timeout”, “error”, “notmodified” 和 “parsererror”。 这是一个 Ajax 事件。 6、type类型：String 默认值: (“GET”)。 请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。 7、url类型：String 默认值: 当前页地址。 发送请求的地址。 8、dataType类型：String 预期接收服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断. “xml”: 返回 XML 文档，可用 jQuery 处理。 “html”: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。 “script”: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 “cache” 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载） “json”: 返回 JSON 数据 。 “jsonp”: JSONP 格式。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 “text”: 返回纯文本字符串 9、data类型：String 发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[“bar1”, “bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。 $.ajax({ type: &quot;POST&quot;, async: true, cache: true, url: &quot;ajax.php&quot;, dataType: &quot;json&quot;, data: {&quot;username&quot;: &quot;bbdog&quot;,&quot;password&quot;: 123456}, contentType: &quot;&quot;, success: function(msg) { console.log(msg) }, error: function() { console.log(&quot;error&quot;) } }) 二、$.post()语法jQuery.post(url,data,success(data, textStatus, jqXHR),dataType) url必需。规定把请求发送到哪个 URL。 data可选。映射或字符串值。规定连同请求发送到服务器的数据。 success(data, textStatus, jqXHR)可选。请求成功时执行的回调函数。 dataType可选。规定预期的服务器响应的数据类型。 默认执行智能判断（xml、json、script 或 html）。 三、$.get()$(selector).get(url,data,success(response,status,xhr),dataType) 参数于post()方法类似 选择器.val().html().text() 操作DOMremove()和empty()删除元素/内容 如需删除元素和内容，一般可使用以下两个 jQuery 方法： remove() - 删除被选元素（及其子元素） empty() - 从被选元素中删除子元素 append()和appendTo$(selector).append(content) $(selector).append(function(index,html)) $(content).appendTo(selector) Tips:append() 和 appendTo() 方法执行的任务相同。不同之处在于：内容和选择器的位置，以及 append() 能够使用函数来附加内容。 .val().html().text() text()//返回文本内容 $(selector).text(); //设置文本内容 $(selector).text(content); //使用函数设置内容 $(selector).text(function(index,oldcontent)) $(selector).attr({attribute:value, attribute:value ...}) class//添加样式 $(selector).addClass(class) //同时添加多个中间用空格隔开 //移除样式 $(selector).removeClass(class) 属性attr //返回属性值 $(selector).attr(attribute) //设置属性值 $(selector).attr(attribute,value) //移除属性值 $(selector).removeAttr(attribute) 可以操作标签的属性和样式的属性；css //返回属性值 $(&quot;p&quot;).css(&quot;background-color&quot;); //设置属性值 $(&quot;p&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;); 隐藏与显示查看显示与隐藏 $(&apos;div:visible&apos;); // 所有可见的div $(&apos;div:hidden&apos;); // 所有隐藏的div 1.hide()和show() //隐藏 $(selector).hide(speed,callback); //显示 $(selector).show(speed,callback); 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。 可选的 callback 参数是隐藏或显示完成后所执行的函数名称。 2.toggle() //显示被隐藏的元素，并隐藏已显示的元素： $(selector).toggle(speed,callback); 3.css(‘display’,*) $(&quot;#id&quot;).css(&apos;display&apos;,&apos;none&apos;);//隐藏 $(&quot;#id&quot;).css(&apos;display&apos;,&apos;block&apos;);//显示 或者 $(&quot;#id&quot;)[0].style.display=&apos;none&apos;; 4.css(‘visibility’,*) $(&quot;#id&quot;).css(&apos;visibility&apos;,&apos;hidden&apos;);//元素隐藏 $(&quot;#id&quot;).css(&apos;visibility&apos;,&apos;visible&apos;);//元素显示 display:none与visible:hidden的区别 visible保留&apos;物理空间&apos;,display不保留&apos;物理空间&apos; 数据类型转换typeof()typeof()可以用来检测给定变量的数据类型,它将返回一个字符串，表示表达式的类型，而表达式的类型只有六种可能： number string boolean object function undefined 转为数字类型转为Int var iNum1 = parseInt(“1234blue”); -&gt; 1234 var iNum2 = parseInt(“oxA”); -&gt; 10 var iNum3 = parseInt(“22.5″); -&gt; 22 var iNum4 = parseInt(“blue”); -&gt; NaN 基模式转为Int var iNum1 = parseInt(“AF”,16); -&gt; 175 var iNum2 = parseInt(“10″,2); -&gt; 2 var iNum3 = parseInt(“10″,8); -&gt; 8 var iNum4 = parseInt(“10″,10); -&gt; 10 如果以0开头最好使用十进制基模式 var iNum1 = parseInt(“010″); -&gt; 8 转为Float var fNum1 = parseFloat(“1234blue”); -&gt; 1234.0 var fNum2 = parseFloat(“0xA”); -&gt; NaN var fNum3 = parseFloat(“.22.5″); -&gt; 0.22 var fNum5 = parseFloat(“0908″); -&gt; NaN var fNum6 = parseFloat(“blue”); -&gt; NaN 转为字符串类型使用toString()方法,常用源数据有Boolean、number、String 1.Boolean var b = true; b.toString(); -&gt; &quot;true&quot; 2.number[默认模式] var num1 = 10.00; num1.toString(); -&gt; &quot;10&quot; 3.number[基（进制基数）模式] var iNum = 10; alert(iNum.toString(2)); -&gt; “1010″ alert(iNum.toString(8)); -&gt; “12″ alert(iNum.toString(16)); -&gt; “A” replace()String.replace(regexp/substr,replacement); var s = &quot;abcd&quot; s = s.replace(&quot;a&quot;,&quot;z&quot;); -&gt; &quot;zbcd&quot; s = s.replace(/c/,&quot;z&quot;); -&gt; &quot;zbzd&quot; s = s.replace(/z/g,&quot;a&quot;); -&gt; &quot;abad&quot; s = s.replace() 将json对象序列化为json字符串contentType: ‘application/json’JSON.stringify(JSONObject) 服务器端可以用JSON.parse将json串还原成JSONObject 数字计算“四舍六入五成双”的toFixed 当有效位后一位，≤4 时舍去,≥6时进1；当等于5时，先判断5后是否还有数，有则进；无数时再判断5数的奇偶性，前为奇数则进1，否则舍去。不同浏览器执行不同ES标准，计算时可能有所不同（尤其IE浏览器） toFixed()返回数字形式的字符串,可参与运算可以用toFixed补全小数点数。 取整Math.round()可先*100 再/100 用于四舍五入。 和传统四舍五入最接近，当有效位后一位，≤4 时舍去,≥6时进1，当等于5时，向正无穷方向取整 待认领window.confirm .dialog .parents $(this) .siblings .not .eq .each .prev .live .is .before .match 数据为空的几种方式null “” undefined正则]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA]]></title>
    <url>%2F2018%2F08%2F02%2F%E5%B7%A5%E5%85%B7-IntelliJ-IDEA%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[FreeMarker]]></title>
    <url>%2F2018%2F08%2F02%2F%E5%89%8D%E7%AB%AF-FreeMarker%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SSM]]></title>
    <url>%2F2018%2F08%2F02%2F%E6%A1%86%E6%9E%B6-SSM%2F</url>
    <content type="text"><![CDATA[abstract 主标签次级标签CRUD标签### 通用参数id 唯一标识parameterType 出入参数类型 flushCachestatementTypetimeout resultTyperesultMapuseCache useGeneratedKeyskeyProperty其他参数：]]></content>
      <categories>
        <category>框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL]]></title>
    <url>%2F2018%2F08%2F02%2F%E6%95%B0%E6%8D%AE%E5%BA%93-SQL%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML]]></title>
    <url>%2F2018%2F08%2F02%2F%E5%89%8D%E7%AB%AF-HTML%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于如何学习方法的总结]]></title>
    <url>%2F2018%2F08%2F02%2F%E6%8A%80%E5%B7%A7-%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[记一些学习技术的方法，用高效的方法去学习新的东西，花点时间去学习 学习的技巧收益会比“努力学习”更高，就像提升加速度比提升速度走的更远。 给一个时间限度首先需要先初步了解要学习的技术，对需要掌握的点有个初步认识。再根据自己可支配的学习时间估算出一个比较合理的截止时间。 动手敲敲怎么防止不学完就忘好记性不如烂笔头，可以搭建一个自己的博客，将自己的收获写在里面。不在乎有多少人去看，重在在于这个整理的过程。费曼学习法中指出，当你能熟练的把一个东西向别人讲述的时候，你也就学会了这个东西。 不放过细小的部分，只要是写出来的东西都要对他负责，不用整理的很细致，把涉及的源码都剖析一遍。重在整个文章能围绕一条中心线走下去。看起来很有层次性。 当你把写博客成为一种习惯，时间长了看看之前写的博客对自己也是一种收获。]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
        <tag>高效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 勿忘启蒙之师 Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
