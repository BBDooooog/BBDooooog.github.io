<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[maven-使用Nexus搭建私服]]></title>
    <url>%2F2019%2F03%2F08%2Fmaven-%E4%BD%BF%E7%94%A8Nexus%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%8D%2F</url>
    <content type="text"><![CDATA[abstract 下载官方下载地址 安装选择合适的位置解压压缩包 这就是Nexus的主要安装目录 当然也可以安装成服务 安装失败，归其原因是因为命令行权限不够，应该使用管理员角色启动命令行 配置主要的几个配置文件路径 nexus-3.15.2-01-win64\nexus-3.15.2-01\bin\nexus.vmoptions nexus-3.15.2-01-win64\nexus-3.15.2-01\etc\nexus-default.properties 例如修改nexus-default.properties中的启动端口1application-port=8686 ##启动 浏览器输入你配置的地址查看Nexus首页]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>Nexus</tag>
        <tag>私服</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis-缓存]]></title>
    <url>%2F2019%2F03%2F01%2FMybatis-%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[abstract 缓存的作用对于变动不频繁的数据，我们通常使用缓存的方式来将数据存起来，从而减少程序对数据库的访问次数，提升查找效率。 Mybatis一级缓存一级缓存是Sqlsession级别的。默认开启。一个Sqlsession对象代表一次数据库会话。一次会话中有可能频繁执行相同查询语句，往往结果短时间内不会变动，对于这种不会变动的数据。Sqlsession会把每次查询的结果放在本地缓存(local cache)，当发现相同查询时，直接从本地缓存中取。减少了对数据库的io和数据库的查询。 Mybatis一级缓存相关接口类SqlSession将它的工作交给了Executor执行器这个角色来完成，负责完成对数据库的各种操作。缓存信息也由Executor执行器维护。 MyBatis将缓存和对缓存相关的操作封装成了Cache接口中。SqlSession、Executor、Cache之间的关系如下列类图所示： BaseExecutor类实现了Executor接口 PerpetualCache类实现了Cache接口 BaseExecutor类的queryFromDatabase等方法可以操纵PerpetualCache类。从而实现了对缓存的操控。 PerpetualCache实现原理其实很简单，其内部就是通过一个简单的HashMap&lt;k,v&gt; 来实现的，没有其他的任何限制。如下是PerpetualCache的实现代码： MyBatis一级缓存工作流程 对于某个查询，根据statementId,params,rowBounds等来构建一个key值，根据这个key值去缓存Cache中取出对应的key值存储的缓存结果； 判断从Cache中根据特定的key值取的数据数据是否为空，即是否命中； 如果命中，则直接将缓存结果返回； 如果没命中： 去数据库中查询数据，得到查询结果； 将key和查询到的结果分别作为key,value对存储到Cache中； 将查询结果返回； 如何判断两次查询是相同的呢结论 判断[statementId + rowBounds + 传递给JDBC的SQL + 传递给JDBC的参数值]组成的CacheKey是否相同。 判断依据 传入的statementId，对于MyBatis而言，你要使用它，必须需要一个statementId，它代表着你将执行什么样的Sql； MyBatis自身提供的分页功能是通过RowBounds来实现的，它通过rowBounds.offset和rowBounds.limit来过滤查询出来的结果集，这种分页功能是基于查询结果的再过滤，而不是进行数据库的物理分页； 由于MyBatis底层还是依赖于JDBC实现的，那么，对于两次完全一模一样的查询，MyBatis要保证对于底层JDBC而言，也是完全一致的查询才行。而对于JDBC而言，两次查询，只要传入给JDBC的SQL语句完全一致，传入的参数也完全一致，就认为是两次查询是完全一致的。 上述的第3个条件正是要求保证传递给JDBC的SQL语句完全一致；第4条则是保证传递给JDBC的参数也完全一致；MyBatis会将上述的SQL中的#{} 转化成？，通过JDBC的PreparedStatement的参数值进行替换，如果参数值相同，则满足自四条Mybatis一级缓存的生命周期生成 随Sqlsession的创建而创建 消亡 SqlSession的close()方法会释放缓存,缓存不可用 SqlSession的clearCache()方法会清空缓存中的内容 SqlSession执行update()、delete()、insert()方法时，会清空缓存中的内容 Mybatis一级缓存注意事项对于数据更新频繁的SQL,应该注意Sqlsession的生存时间，或是再mapper文件中禁用一级缓存 Mybatis一级缓存扩展PerpetualCache类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* * Copyright 2009-2012 The MyBatis Team * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.ibatis.cache.impl;import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;import org.apache.ibatis.cache.Cache;import org.apache.ibatis.cache.CacheException;public class PerpetualCache implements Cache &#123; private String id; private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;(); private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); public PerpetualCache(String id) &#123; this.id = id; &#125; public String getId() &#123; return id; &#125; public int getSize() &#123; return cache.size(); &#125; public void putObject(Object key, Object value) &#123; cache.put(key, value); &#125; public Object getObject(Object key) &#123; return cache.get(key); &#125; public Object removeObject(Object key) &#123; return cache.remove(key); &#125; public void clear() &#123; cache.clear(); &#125; public ReadWriteLock getReadWriteLock() &#123; return readWriteLock; &#125; public boolean equals(Object o) &#123; if (getId() == null) throw new CacheException("Cache instances require an ID."); if (this == o) return true; if (!(o instanceof Cache)) return false; Cache otherCache = (Cache) o; return getId().equals(otherCache.getId()); &#125; public int hashCode() &#123; if (getId() == null) throw new CacheException("Cache instances require an ID."); return getId().hashCode(); &#125;&#125; BaseExecutor类的queryFromDatabase方法 1234567891011121314private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; List&lt;E&gt; list; localCache.putObject(key, EXECUTION_PLACEHOLDER); try &#123; list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql); &#125; finally &#123; localCache.removeObject(key); &#125; localCache.putObject(key, list); if (ms.getStatementType() == StatementType.CALLABLE) &#123; localOutputParameterCache.putObject(key, parameter); &#125; return list;&#125; Mybatis二级缓存二级缓存是mapper级别的。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库-多表关联]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%A4%9A%E8%A1%A8%E5%85%B3%E8%81%94%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git-常用操作]]></title>
    <url>%2F2019%2F01%2F28%2FGit-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[abstract 设置用户信息设置用户名、邮箱全局通用用户信息，本机上所有的Git仓库都是使用这个账号。123git config --global user.name "userName"git config --global user.email "userEmail" 也可以针对某个仓库指定用户名和邮箱 仓库相关初始化仓库使用初始化仓库命令可以在一个打算作为仓库的目录中生成一个.git目录，这个目录就是用作版本控制的文件目录。 1git init 将文件从工作区添加到暂存区1git add 文件名 查看文件提交状态1git status 这个命令会比对仓库与暂存区文件差异，并将差异展现出来。 查看差异1git diff 文件名 将会展现Unix中diff差异格式。 将文件从暂存区提交到仓库1git commit -m "更新说明" 1git commit -a -m "更新说明" 加上-a参数会执行 add + commit 命令 查看版本1git log 默认按更新日期从近到远展示三次提交记录。展示信息如下： commit 最近一次版本号 Author: 用户名&lt;邮箱&gt; Date: 日期 更新说明 commit 上上次版本号 Author: 用户名&lt;邮箱&gt; Date: 日期 更新说明 也可以展示简略信息1git log –-pretty=oneline 展示信息如下： 版本号 更新说明 版本号 更新说明 版本号 更新说明 跳转到某一个版本1234567git reset --hard HEAD^``` 跳转到上一次，`HEAD^^`,挑战到上上次。`HEAD^^^`跳转到上上上次。那么问题来了，上一百次怎么复制粘贴最合理？但其实并不需要```bashgit reset --hard HEAD~100 回退之后后悔了怎么办。git log 也看不到版本号了鸭，这个时候操作1git reflog]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaIO-字节流]]></title>
    <url>%2F2019%2F01%2F25%2FJavaIO-%E5%AD%97%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[abstract 1234567891011121314151617import java.io.*;public class TestExcel&#123; public static void main(String[] args) throws Exception &#123; String fileName = "D:" + File.separator + "OutputStream.txt"; File file = new File(fileName); OutputStream out = new FileOutputStream(file);; byte b0[] = "测试输入输出流".getBytes(); //操作字节流，要转换成字节 out.write(b0); out.close(); InputStream in = new FileInputStream(file); byte b1[] = new byte[(int)file.length()]; int i = 0; i = in.read(b1); System.out.println(i); System.out.println(new String(b1, 0, i)); &#125; console 21 测试输入输出流]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaIO-File中常用方法]]></title>
    <url>%2F2019%2F01%2F25%2FJavaIO-File%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[abstract ## 示例123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args)&#123; String fileName = "D:" + File.separator + "Files"; File file = new File(fileName); // 判断路径指向的文件/文件夹是否存在、是否目录 if (file.exists() &amp;&amp; file.isDirectory())&#123; System.out.println("file是一个文件夹\n"); File[] files = file.listFiles(); // 获取目录下的所有文件/文件夹（仅该层路径下） System.out.print("路径下有文件："); for (File f : files) &#123; System.out.print(f + "\t"); &#125; //信息 System.out.println("files[0]的文件名：" + files[0].getName()); // 获取文件名、文件夹名 System.out.println("files[0]的文件路径：" + files[0].getPath()); // 获取文件、文件夹路径 System.out.println("files[0]的绝对路径：" + files[0].getAbsolutePath()); // 获取文件、文件夹绝对路径 System.out.println("files[0]的父文件夹名：" + files[0].getParent()); // 获取文件父目录路径 System.out.println("files[0]的最后修改时间：" + files[0].lastModified()); // 获取文件、文件夹上一次修改时间 System.out.println("files[0]的大小：" + files[0].length() + " Bytes"); // 获取文件的字节数，如果是一个文件夹则这个值为0 System.out.println("files[0]的路径转换为URI：" + files[0].toURI()); // 获取文件路径URI后的路径名 //状态 System.out.println(files[0].exists() ? "files[0]的存在" : "files[0]的不存在"); // 判断文件、文件夹是否存在 System.out.println(files[0].canWrite() ? "files[0]的可写" : "files[0]的不可写"); // 判断文件是否可写 System.out.println(files[0].canRead() ? "files[0]的可读" : "files[0]的不可读"); // 判断文件是否可读 System.out.println(files[0].canExecute() ? "file[0]可执行" : "file[0]不可执行"); // 判断文件是否可执行 System.out.println(files[0].isDirectory() ? "files[0]的是目录" : "files[0]的不是目录"); // 判断文件、文件夹是不是目录 System.out.println(files[0].isFile() ? "files[0]的是文件" : "files[0]的不是文件"); // 判断拿文件、文件夹是不是标准文件 System.out.println(files[0].isAbsolute() ? "files[0]的路径名是绝对路径" : "files[0]的路径名不是绝对路径"); // 判断路径名是不是绝对路径 //操作 if (files[0].exists()) files[0].delete(); // 删除指定的文件、文件夹 if (files[1].exists()) files[1].deleteOnExit(); // 当虚拟机终止时删除指定的文件、文件夹 &#125;&#125; 输出结果： file是一个文件夹 路径下有文件：D:\Files\BBDog.txt files[0]的文件名：BBDog.txt files[0]的文件路径：D:\Files\BBDog.txt files[0]的绝对路径：D:\Files\BBDog.txt files[0]的父文件夹名：D:\Files files[0]的存在 files[0]的可写 files[0]的可读 file[0]可执行 files[0]的不是目录 files[0]的是文件 files[0]的路径名是绝对路径 files[0]的最后修改时间：1548408240577 files[0]的大小：6 Bytes files[0]的路径转换为URI：file:/D:/Files/BBDog.txt 说明指定文件名时推荐使用File.separator,来实现跨平台目录分隔符-程序会判断系统类型从而展现不同的分隔符。 删除操作必须目录下没有目录或文件]]></content>
      <categories>
        <category>Java IO</category>
      </categories>
      <tags>
        <tag>File</tag>
        <tag>文件流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架-TreeSet]]></title>
    <url>%2F2019%2F01%2F24%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-TreeSet%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架-TreeMap]]></title>
    <url>%2F2019%2F01%2F24%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-TreeMap%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架-HashTable]]></title>
    <url>%2F2019%2F01%2F24%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-HashTable%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架-HashSet]]></title>
    <url>%2F2019%2F01%2F24%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-HashSet%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架-HashMap]]></title>
    <url>%2F2019%2F01%2F24%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-HashMap%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架-LinkedList]]></title>
    <url>%2F2019%2F01%2F24%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-LinkedList%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
  </entry>
  <entry>
    <title><![CDATA[尝试-尝试实现扫二维码登陆]]></title>
    <url>%2F2019%2F01%2F24%2F%E5%B0%9D%E8%AF%95-%E5%B0%9D%E8%AF%95%E5%AE%9E%E7%8E%B0%E6%89%AB%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[TODO 方式一生成二维码要想二维码唯一，用于生成二维码的 长地址转短地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.util.LinkedList;import java.util.List;import org.apache.http.NameValuePair;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpPost;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;/*** * 短链接转换工具类 * * @author Administrator * */public class ShortUrlHelper &#123; public static CloseableHttpClient httpClient; static &#123; httpClient = HttpClients.createDefault(); &#125; /** * 将长链接转为短链接(调用的新浪的短网址API) * * @param url * 需要转换的长链接url * @return 返回转换后的短链接 */ public static String convertSinaShortUrl(String url) &#123; try &#123; // 调用新浪API HttpPost post = new HttpPost("http://api.t.sina.com.cn/short_url/shorten.json"); List&lt;NameValuePair&gt; params = new LinkedList&lt;NameValuePair&gt;(); // 必要的url长链接参数 params.add(new BasicNameValuePair("url_long", url)); // 必要的新浪key params.add(new BasicNameValuePair("source", "3271760578")); post.setEntity(new UrlEncodedFormEntity(params, "UTF-8")); CloseableHttpResponse response = httpClient.execute(post); // 得到调用新浪API后成功返回的json字符串 // url_short : 短链接地址 type：类型 url_long：原始长链接地址 String json = EntityUtils.toString(response.getEntity(), "utf-8"); JSONArray jsonArray = JSONArray.parseArray(json); JSONObject object = (JSONObject) jsonArray.get(0); return object.getString("url_short"); &#125; catch (Exception e) &#123; e.printStackTrace(); return ""; &#125; &#125; /** * 将长链接转为短链接(调用的百度短网址API) * * @param url * 需要转换的长链接url * @return 返回转换后的短链接 */ public static String convertBaiDuShortUrl(String url) &#123; try &#123; // 调用百度API HttpPost post = new HttpPost("http://www.dwz.cn/create.php"); List&lt;NameValuePair&gt; params = new LinkedList&lt;NameValuePair&gt;(); // 必要的url长链接参数 params.add(new BasicNameValuePair("url", url)); post.setEntity(new UrlEncodedFormEntity(params, "UTF-8")); CloseableHttpResponse response = httpClient.execute(post); // 得到调用百度API后成功返回的json字符串 // tinyurl : 短链接地址 status：0 表示转换成功 非0表示转换失败 longurl：原始长链接地址 err_msg:错误信息 String jsonStr = EntityUtils.toString(response.getEntity(), "utf-8"); JSONObject object = JSON.parseObject(jsonStr); return object.getString("tinyurl"); &#125; catch (Exception e) &#123; e.printStackTrace(); return ""; &#125; &#125; /** * 测试 * @param args */ public static void main(String []args)&#123; String tinyurl = convertBaiDuShortUrl("http://news.sina.com.cn/gov/xlxw/2018-09-05/doc-ihiixyeu3395739.shtml"); System.out.println(tinyurl); &#125;&#125; 轮询判断二维码状态（服务器请求压力） 未扫描 扫描成功 过时刷新 扫码uid绑定用户(额外库)稍后轮询会返回扫描成功 点击登陆方式二生成二维码扫码通知后台进行登陆 推送 未扫码，不推送 扫码成功，用户信息页 点击登陆]]></content>
      <categories>
        <category>尝试</category>
      </categories>
      <tags>
        <tag>二维码</tag>
        <tag>登陆</tag>
        <tag>短地址</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[规范-特殊注释]]></title>
    <url>%2F2019%2F01%2F23%2F%E8%A7%84%E8%8C%83-%E7%89%B9%E6%AE%8A%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[1TODO:这里将要放一个华丽又不失内涵的简介 特殊注释 TODO: 标识该处有功能代码待编写，待实现的功能在说明中会简略说明。 FIXME: 标识该处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。 XXX: 标识该处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>TODO</tag>
        <tag>XXX</tag>
        <tag>FIXME</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用方法-集合工具类常用方法]]></title>
    <url>%2F2019%2F01%2F23%2FJava%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[真香~ 对象List按属性排序1234567891011121314151617181920212223242526272829303132333435363738394041class Animal&#123; private String kind; private int quantity; public Animal(String k,int q)&#123; this.kind = k; this.quantity = q; &#125;&#125;public class Main&#123; public static void main(String[] args) &#123; Animal dog = new Animal("狗",10000); Animal cat = new Animal("猫",5000); Animal pig = new Animal("猪",2000); List&lt;Animal&gt; animalList = new ArrayList&lt;Animal&gt;(); animalList.add(dog); animalList.add(cat); animalList.add(pig); Collections.sort(animalList, new Comparator&lt;TestA&gt;() &#123; @Override public int compare(TestA o1, TestA o2) &#123; //升序 return o1.getAge().compareTo(o2.getAge()); &#125; &#125;); Collections.sort(animalList, new Comparator&lt;TestA&gt;() &#123; @Override public int compare(TestA o1, TestA o2) &#123; //降序 return o1.getAge().compareTo(o2.getAge()); &#125; &#125;); &#125;&#125; List初始化时进行赋值1List&lt;Long&gt; ids = Arrays.asList(98765432109L,12345678901L);]]></content>
      <categories>
        <category>Java常用方法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>List</tag>
        <tag>对象</tag>
        <tag>属性</tag>
        <tag>初始化</tag>
        <tag>赋值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架-ArrayList]]></title>
    <url>%2F2019%2F01%2F17%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-ArrayList%2F</url>
    <content type="text"><![CDATA[abstract 结构本文使用jdk1.8.0_131 继承了 AbstractList 实现了 List Cloneable 实现了Clone(),使自身可以被克隆； Serializable 支持序列化传输； RandomAccess 实现了随机访问 特性 ArrayList是一个动态数组，初始容量是10 增长方式int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1) ArrayList不是线程安全的，因此只在单线程中使用，多线程用Vector. 重要属性和方法12345678910111213141516171819202122/** * Default initial capacity. */private static final int DEFAULT_CAPACITY = 10;transient Object[] elementData; // non-private to simplify nested class accessprivate int size;private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; 容量大小(capacity)和实际大小（size）不是一回事。 构造方法1234567891011121314151617181920212223242526272829//默认构造方法，创建一个默认容量（10）的数组public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;//指定容量的构造方法public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125;//对泛型不是很了解，日后补充，addpublic ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; API使用循环12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.*;public class TestExcel&#123; public static void main(String[] args) throws Exception &#123; List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); for (int i = 0 ; i&lt;100; i++) ids.add(i); randomFor(ids); foreach(ids); iterator(ids); &#125; public static void randomFor(List&lt;Integer&gt; ids)&#123; Long start; Long end; start = System.nanoTime(); for (int i=0; i&lt;ids.size(); i++) &#123; ids.get(i); &#125; end = System.nanoTime(); System.out.println("randomFor:"+(end-start)+"ns"); &#125; public static void foreach(List&lt;Integer&gt; ids)&#123; Long start; Long end; start = System.nanoTime(); for (Integer integ:ids) &#123; ; &#125; end = System.nanoTime(); System.out.println("foreach:"+(end-start)+"ns"); &#125; public static void iterator(List&lt;Integer&gt; ids)&#123; Long start; Long end; start = System.nanoTime(); for(Iterator iter = ids.iterator(); iter.hasNext(); ) &#123; iter.next(); &#125; end = System.nanoTime(); System.out.println("iterator:"+(end-start)+"ns"); &#125;&#125; 1. randomFor:72482ns foreach:232867ns iterator:13879ns1. randomFor:70939ns foreach:200482ns iterator:27245ns randomFor:74538nsforeach:223614nsiterator:25703nsnanotime精确程度有待质疑，但大体能够反映出来一个差距。 数量级 100 1000 10000 100000 1000000 10000000 100000000 randomFor 72482ns 208706ns 882118ns 4ms 5ms 4ms 5ms foreach 223614ns 606585ns 1159708ns 5ms 13ms 24ms 219ms iterator 25703ns 249317ns 277076ns 3ms 6ms 6ms 13ms 亿级开始,放数据的时间媛媛大于循环的时间。 算了半天我感觉效率比显而易见，但是又有多少list需要放亿级的数据呢。最大只能放 优化建议Java集合框架清单]]></content>
      <categories>
        <category>Java集合框架</category>
      </categories>
      <tags>
        <tag>List</tag>
        <tag>ArrayList</tag>
        <tag>add</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-Java常用关键字]]></title>
    <url>%2F2019%2F01%2F16%2FJava%E5%9F%BA%E7%A1%80-Java%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[abstract final修饰类被final修饰的类不能被继承 修饰方法 “使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。” 由此可见，被final修饰的方法最主要的目的就是防止方法被重写 修饰变量对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 对象的引用无法改变，但是对象的属性值可不可以改变呢？ 因为payStatus是int类型，初始化时候会给定默认值：0 此时输出结果 1 10 从结果来看，final”锁定”的是对象的引用，并没有”锁定”属性的值； 注意事项final与static的区别,static作用于成员变量用来表示只保存一份副本，而final的作用是用来保证变量不可变。 示例：123456789101112131415final class Father&#123; public final Double i = Math.random(); public static Double j = Math.random();&#125;public static void main(String[] args)&#123; Father f = new Father(); Father ff = new Father(); System.out.println(f.i); System.out.println(f.j); System.out.println(); System.out.println(ff.i); System.out.println(ff.j);&#125; 输出结果： 0.41791403026319096 0.8147697161273327 0.9571817275395188 0.8147697161273327 参考资料博客园-海子-浅析Java中的final关键字 博客园-五月的仓颉-谈谈final的作用 static 静态方法内部不能调用非静态方法，非静态方法没有此限制。 被static修饰的变量属于类变量，可以通过类名.变量名直接引用，而不需要new出一个类来 被static修饰的方法属于类方法，可以通过类名.方法名直接引用，而不需要new出一个类来 静态资源是类初始化的时候加载的，类实例之间共享，一处变，处处变。 并且被static修饰的方法是没有this的，他不依附于任何对象。但是非静态方法是依赖于具体对象而调用的。这就是为什么静态方法内部不能调用非静态方法。 既然静态资源不依赖于任何对象，那为什么还要放在不同对象里呢。是不是可以把所有静态资源全都放到一起? 避免重名，通过不同对象使同名静态资源区分开。 资源分类清晰，功能明确。 放到一起，那存放静态资源的这个类会特别大。 静态资源（变量/方法/代码块）static变量也称作静态变量，静态变量和非静态变量的区别是： 静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。 很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。 注意事项静态资源真的没有this吗？ 1234567891011121314151617final class Father&#123; static int wg = 31; public void pringtWg()&#123; int wg = 13; System.out.println(this.wg); &#125;&#125;public class TestExcel &#123; public static void main(String[] args) throws Exception &#123; new Father().pringtWg(); &#125;&#125; 输出： 31 this是指当前对象，printWg中的wg是局部变量，无法与this内联。 常见面试题一1234567891011121314151617181920212223242526public class Son extends Father&#123; static&#123; System.out.println("son static"); &#125; public Test()&#123; System.out.println("son constructor"); &#125; public static void main(String[] args) &#123; System.out.println("main()"); new Son(); &#125;&#125;class Father&#123; static&#123; System.out.println("father static"); &#125; public Base()&#123; System.out.println("father constructor"); &#125;&#125; 输出： father static son static main() father constructor son constructor 程序执行顺序： main()作为程序入口； 需要加载Son,发现Son继承Father，加载Father; Father中有static块，初始化加载这个static块； 返回Son,Son中有static块，初始化这个static块； 打印输出字符串”main()” 执行new Son(); Son继承Father，Father有构造函数，执行构造函数； 返回Son,Son有构造函数，执行构造函数； 第2~4步是对象的加载过程，第5~7步是对象的执行过程；输出结果与执行顺序的对应关系 输出行 对应执行顺序 father static 3 son static 4 father constructor 7 son constructor 8 不难发现即使mian()中并没有语句，但仍然会有输出。就像之前所说，jvm会把所有不在方法内部的的静态资源初始化。 参考资料博客园-海子-浅析Java中的final关键字 博客园-五月的仓颉-谈谈final的作用 包和访问权限控制关键字package 包是可以理解为命名空间，他能有效解决类重名问题。 为了方便组织和管理，多用倒置域名来标识。 默认访问权限（包访问权限）、public、private和protected一个.java文件只能有一个被public修饰的类，并且类名必须与文件名相同。如果没有public关键字，则对类的命名没有要求。 修饰类 默认访问权限（包访问权限）：用来修饰类的话，表示该类只对同一个包中的其他类可见。 public：用来修饰类的话，表示该类对其他所有的类都可见。 如果你想实现其他任何人都不能访问该类，可以通过将类的所有构造器都指定为private。1234567891011121314151617package com.qigou.b2cex.test;class People &#123; private String name = null; public People(String name) &#123; this.name = name; &#125; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125;&#125; 1234567package com.qigou.b2cex.test;public class TestExcel&#123; public static void main(String[] args) throws Exception &#123; System.out.println(new People("BBDog").getName()); &#125;&#125; 输出结果： BBDog 将People的包名改为test1后 修饰方法和变量 作用域 当前类 同包下 子孙 所有类 public √ √ √ √ protected √ √ √ × 默认 √ √ × × private √ × × × 1234567891011121314151617package com.qigou.b2cex.test;public class People &#123; private String name = null; public People(String name) &#123; this.name = name; &#125; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125;&#125; 12345678package com.qigou.b2cex.test;public class TestExcel&#123; public static void main(String[] args) throws Exception &#123; People people = new People("BBDog"); System.out.println(people.getName()); &#125;&#125; 变更getName()的权限,每次初始化包名。 public 正常输出： BBDog 默认 同包下正常输出： BBDog 修改People包名为test1 protected 同包下正常输出： BBDog 修改People包名为test1 创建Kids类继承People 12345678910111213package com.qigou.b2cex.test;import com.qigou.b2cex.test1.People;public class Kids extends People &#123; public Kids(String name)&#123; super(name); &#125; public String toString() &#123; return getName(); &#125;&#125; 子类拥有权限，但是调用子类仍然不被允许 private 参考资料 博客园-海子-浅析Java中的final关键字]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>关键字</tag>
        <tag>final</tag>
        <tag>static</tag>
        <tag>package</tag>
        <tag>访问控制</tag>
        <tag>public</tag>
        <tag>private</tag>
        <tag>protected</tag>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElasticSearch单机集群搭建与ElasticHD]]></title>
    <url>%2F2019%2F01%2F11%2F%E6%A1%86%E6%9E%B6-ElasticSearch%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E4%B8%8EElasticHD%2F</url>
    <content type="text"><![CDATA[abstract 本机环境操作系统及位数 下载ES及分词器选择用户为什么要把选择用户单独列一项，因为ElasticSearch无法在ROOT下启动。所以，安装、配置、创建所需目录也都提前到选择用户之后。 安装##]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
        <tag>ES</tag>
        <tag>ElasticHD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[equals()和hashCode()]]></title>
    <url>%2F2019%2F01%2F07%2FJava%E5%9F%BA%E7%A1%80-equals%E5%92%8ChashCode%2F</url>
    <content type="text"><![CDATA[原生equals()底层源码通过==来实现，比较的是两个对象（两个对象的引用地址）。 hashCode()是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值. 两个对象的equals()相等（原生），hashCode()一定相等； 两个对象hashCode()相等，epuals()并不一定相等。 equals() 原生equals()底层源码通过==来实现，比较的是两个对象（两个对象的引用地址）。 重写equals()用来比较两个对象的内容是否相等。 常用覆盖逻辑12345678910111213141516171819202122/** * @desc 覆盖equals方法 */ public boolean equals(Object obj)&#123; if(obj == null)&#123; return false; &#125; //如果是同一个对象返回true，反之返回false if(this == obj)&#123; return true; &#125; //判断是否类型相同 if(this.getClass() != obj.getClass())&#123; return false; &#125; //比较对象属性值是否相等 //例如 Person中有两个属性 name,age Person person = (Person)obj; return name.equals(person.name) &amp;&amp; age==person.age; &#125; hashCode()hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值.对象的地址或者字符串或者数字就是keys，通过一个函数算出hash. hashCode=F(key); hashCode() 在散列表中才有用，在其它情况下没用。在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置； 两个对象的equals()相等（原生），hashCode()一定相等； 两个对象hashCode()相等，epuals()并不一定相等。 我们应该根据对象的特点，重写hashCode方法，尽量避免（3）提到的哈希冲突情况。 HashSet判定一个对象是否重复： HashSet判定为重复对象。 未重写equals()和hashCode()时: code: 123456789Person p1 = new Person("aaa",1);Person p2 = p1;Person p3 = new Person("bbb",1);Set&lt;Person&gt; PS = Sets.newHashSet();PS.add(p1);PS.add(p2);PS.add(p3);System.out.println(p1.equals(p2));System.out.printf(PS+"====》"+"p1.hashCode(%s)==&gt;p2.hashCode(%s)==&gt;p3.hashCode(%s)",p1.hashCode(),p2.hashCode(),p3.hashCode()); console： 12true[aaa - 1, bbb - 1]====》p1.hashCode(1047503754)==&gt;p2.hashCode(1047503754)==&gt;p3.hashCode(1722023916) 我们知道原生equals()相等时，hashCode一定相等； code: 123456789Person p1 = new Person("aaa",1);Person p2 = new Person("aaa",1);Person p3 = new Person("bbb",1);Set&lt;Person&gt; PS = Sets.newHashSet();PS.add(p1);PS.add(p2);PS.add(p3);System.out.println(p1.equals(p2));System.out.printf(PS+"====》"+"p1.hashCode(%s)==&gt;p2.hashCode(%s)==&gt;p3.hashCode(%s)",p1.hashCode(),p2.hashCode(),p3.hashCode()); console： 12false[bbb - 1, aaa - 1, aaa - 1]====》p1.hashCode(1047503754)==&gt;p2.hashCode(1722023916)==&gt;p3.hashCode(2009787198) 只重写hashCode()时： code: 123456789101112131415161718private static class Person &#123; @Override public int hashCode()&#123; int nameHash = name.toUpperCase().hashCode(); return nameHash ^ age; &#125;&#125;public static void main(String[] args)&#123; Person p1 = new Person("aaa",1); Person p2 = new Person("aaa",1); Person p3 = new Person("bbb",1); Set&lt;Person&gt; PS = Sets.newHashSet(); PS.add(p1); PS.add(p2); PS.add(p3); System.out.println(p1.equals(p2)); System.out.printf(PS+"====》"+"p1.hashCode(%s)==&gt;p2.hashCode(%s)==&gt;p3.hashCode(%s)",p1.hashCode(),p2.hashCode(),p3.hashCode()); &#125; console: 12false[aaa - 1, aaa - 1, bbb - 1]====》p1.hashCode(64544)==&gt;p2.hashCode(64544)==&gt;p3.hashCode(65539) 只重写equals()时： code: 123456789101112131415161718192021222324252627282930313233private static class Person &#123; @Override public boolean equals(Object obj)&#123; if(obj == null)&#123; return false; &#125; //如果是同一个对象返回true，反之返回false if(this == obj)&#123; return true; &#125; //判断是否类型相同 if(this.getClass() != obj.getClass())&#123; return false; &#125; Person person = (Person)obj; return name.equals(person.name) &amp;&amp; age==person.age; &#125;&#125;public static void main(String[] args)&#123; Person p1 = new Person("aaa",1); Person p2 = new Person("aaa",1); Person p3 = new Person("bbb",1); Set&lt;Person&gt; PS = Sets.newHashSet(); PS.add(p1); PS.add(p2); PS.add(p3); System.out.println(p1.equals(p2)); System.out.printf(PS+"====》"+"p1.hashCode(%s)==&gt;p2.hashCode(%s)==&gt;p3.hashCode(%s)",p1.hashCode(),p2.hashCode(),p3.hashCode()); &#125; console: 12true[bbb - 1, aaa - 1, aaa - 1]====》p1.hashCode(1047503754)==&gt;p2.hashCode(1722023916)==&gt;p3.hashCode(2009787198) 同时重写equals()和hashCode()时： code: 1234567891011public static void main(String[] args)&#123; Person p1 = new Person("aaa",1); Person p2 = new Person("aaa",1); Person p3 = new Person("bbb",1); Set&lt;Person&gt; PS = Sets.newHashSet(); PS.add(p1); PS.add(p2); PS.add(p3); System.out.println(p1.equals(p2)); System.out.printf(PS+"====》"+"p1.hashCode(%s)==&gt;p2.hashCode(%s)==&gt;p3.hashCode(%s)",p1.hashCode(),p2.hashCode(),p3.hashCode()); &#125; console: 12true[aaa - 1, bbb - 1]====》p1.hashCode(64544)==&gt;p2.hashCode(64544)==&gt;p3.hashCode(65539) 至此我们推断HashSet的判重逻辑是，hashCode()与equals()同时满足]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>equals</tag>
        <tag>hashCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM学习-内存模型]]></title>
    <url>%2F2019%2F01%2F05%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Xmind Zen 挺好用的 学习了《深入理解Java虚拟机》–周志明之后的一点点个人总结，如有错误还请指正。 文字版如下 运行时内存线程私有虚拟机栈 描述 java方法执行的内存模型 存储局部变量表、操作数栈、动态链接、方法出口等信息 方法开始执行时，创建栈帧 从方法执行到执行完成对应（一个栈帧）入栈出栈的过程 功能 局部变量表 存放该方法调用者所传入的参数，及在该方法的方法体中创建的局部变量。 对象引用(reference类型) 可能是指向对象起始地址的引用指针 也可能是指向一个代表对象的句柄 returnAddress类型 指向一条字节码指令的地址 多线程 生命周期与线程一致 抛出异常 线程请求深度大于虚拟机栈允许最大深度时 StackOverflowError 虚拟机栈可以动态扩展，无法申请到足够内存 OutOfMemoryError 本地方法栈 描述 与虚拟机栈十分相似 只不过针对Native方法服务 功能 多线程 生命周期与线程一致 抛出异常 同虚拟机栈异常 程序计数器 描述 当前线程所执行字节码的行号指示器 功能 字节码解释器改变计数器的值 如果执行的是native方法，则计数器值为空 多线程 每个线程的计数器互不影响，相互独立 jvm多线程的理解 jvm通过轮流分配处理器执行时间，实现多线程 共享区域java堆 描述 虚拟机启动时创建 功能 存放对象的实例 jit编译器与逃逸分析技术的发展，栈上分配、标量替换使这一条不那么绝对 存放数组 为了更好的分配和回收会进行细分、功能不变 新生代和老年代 Eden空间、From Survivor空间、To Survivor空间 线程私有的分配缓冲区 TLAB GC 内存回收的主要区域 抛出异常 堆中没有内存可以完成实力分配并且没法扩展时 OutOfMemoryError 参数 -Xmx -Xms 方法区 主区域 描述 堆的逻辑区域 功能 存储已被虚拟机加载的类信息 类的版本、字段、方法、接口等描述信息 常量池 常量 静态变量 即时编辑器编译后的代码 特点 不需要连续的内存空间 可固定可扩展 可以不实现垃圾回收（垃圾回收在此区相对较少） 参数 有些虚拟机把分代收集扩展到方法区称为永久代 永久代大小 -XX:MaxPermSize 运行时常量池 描述 用于存放编译期生成的各种字面变量和符号引用 功能 还可以保存翻译出来的直接引用 特点 相对于Class文件常量池具备动态性 运行期间也可以讲新的常量放入池中 String.intern() 抛出异常 方法区无法满足内存分配需求时 OutOfMemoryError 直接内存 描述 NIO类可以操作Native函数库直接分配堆外内存 通过存储在堆中的DirectByteBuffer对象作为这块内存引用操作 抛出异常 OutOfMemoryError 参数 主动设置 -XX:maxDirectMemorySize 默认 -Xms 对象对象的创建 类加载 先通过New指令的参数去常量池中定位到一个类的符号引用 编译时并不知道一个类的直接内存地址，只能使用（符号）来标识类的地址 如果没有，执行相应的类加载过程 分配内存空间 类加载完成后所需的大小可以完全确定 将所需的内存区域从Java堆中划分出来 内存分配方式 规整的内存（已用和未用有一个区分界限） 零散的区域 需要一个空闲列表来统计空闲区域 内存分配时并发性问题 描述 正在给A对象分配，指针还没来得及移动，要开始分配B对象，使用了A对象内存区域 解决方案 动作原子性控制 CAS配上失败重试 作用域控制 为每个线程在堆中分配TLAB,每个线程在自己的区域中划分内存 如果原来的缓冲区域用完了，需要新的缓冲区来划分内存，则需要同步锁来保证完整性 启用TLAB -XX:+/-UseTLAB 翻台 将分配的内存区域置零 不包括对象头 如果使用TLAB，这一步在TLAB分配时完成 设置 根据对象头 对象是那个类的实例 如何才能找到类的元数据信息 对象的哈希码 对象的GC分代年龄等 至此一个对象创建完成，但是对于Java程序来讲对象的创建才刚刚开始，接下来执行init方法 对象的内存布局 对象头包含两部分信息 运行时数据、信息 位数固定 如果储存的信息太多时会复用位数空间 类型指针 即指向它类元数据的指针 虚拟机通过这个指针来确定对象是哪个类的实例 真正储存的有效信息 各类型字段（包括父类） 存储顺序 虚拟机分配策略参数 相同宽度的字段总是被分配到一起 父类定义的变量会在子类之前 字段在Java源码中的定义顺序 对齐填充 保证地址空间时8字节的整数倍 对象的访问定位 通过栈上的reference数据来操作对象 指向对象的引用 访问方式 句柄 Java堆中划分出一块句柄池 reference存储句柄地址 句柄包含对象实例数据与类型数据各自的具体信息 直接指针 Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息 优缺点 直接指针访问速度快，对象移动时需要改变栈中reference 句柄每次访问查一遍句柄池，但是对象移动（垃圾收集时）不需要修改栈中reference]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习JVM前的准备]]></title>
    <url>%2F2019%2F01%2F05%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AD%A6%E4%B9%A0JVM%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[一个java程序的分娩过程 一个java程序的分娩过程大致可以分为一下四步 生成.java文件此处不必多说，但需要注意语法 生成.class文件使用Javac命令可将.java文件编译成.class文件 使用java -v [.class文件名]查看字节码文件使用java -v [.class文件名] &gt; [输出文件路径]将字节码文件输出到指定路径的文件中java的跨平台性就体现在无论以何种方式生成字节码文件，只要字节码文件符合规范。jvm都能运行此处推荐一个.class文件查看器github:jclasslib 类加载器加载.class文件 类加载器会通过CLASSPATH找到需要执行的.class文件 读取字节码文件流，储存在方法区中3.执行引擎找到main()作为入口图片来自百度百科]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
        <tag>字节码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis-generator]]></title>
    <url>%2F2018%2F11%2F23%2F%E5%B7%A5%E5%85%B7-mybatis-generator%2F</url>
    <content type="text"><![CDATA[abstract 添加依赖1234567891011&lt;!-- mybatis generator 自动生成代码插件 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; 编辑配置文件在&lt;configurationFile&gt;指向的位置添加generatorConfig.xml文件当前目录123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt; &lt;classPathEntry location="D:\bbgog\bbdog-maven\maven-repository\org\mariadb\jdbc\mariadb-java-client\2.3.0\mariadb-java-client-2.3.0.jar"/&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass="org.mariadb.jdbc.Driver" connectionURL="jdbc:mariadb://localhost:3306/test" userId="root" password="123456"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置--&gt; &lt;javaModelGenerator targetPackage="com.demo.entity" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件的包名和位置--&gt; &lt;sqlMapGenerator targetPackage="mapping" targetProject="src/main/resources"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成mapper的包名和位置--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.demo.mapper" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt; &lt;table tableName="user" domainObjectName="User" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 启动generator在指定位置新建需求表123456CREATE TABLE USER ( user_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, user_name VARCHAR ( 255 ) NOT NULL, PASSWORD VARCHAR ( 255 ) NOT NULL, phone VARCHAR ( 255 ) NOT NULL) ENGINE = INNODB AUTO_INCREMENT = 1000 DEFAULT CHARSET = utf8; 双击启动generator 生成后项目目录 生成对应POJO类 生成对应mapper 生成对应mapper.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.demo.mapper.UserMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.demo.entity.User" &gt; &lt;id column="user_id" property="userId" jdbcType="INTEGER" /&gt; &lt;result column="user_name" property="userName" jdbcType="VARCHAR" /&gt; &lt;result column="password" property="password" jdbcType="VARCHAR" /&gt; &lt;result column="phone" property="phone" jdbcType="VARCHAR" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; user_id, user_name, password, phone &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from user where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from user where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.demo.entity.User" &gt; insert into user (user_id, user_name, password, phone) values (#&#123;userId,jdbcType=INTEGER&#125;, #&#123;userName,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, #&#123;phone,jdbcType=VARCHAR&#125;) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.demo.entity.User" &gt; insert into user &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="userId != null" &gt; user_id, &lt;/if&gt; &lt;if test="userName != null" &gt; user_name, &lt;/if&gt; &lt;if test="password != null" &gt; password, &lt;/if&gt; &lt;if test="phone != null" &gt; phone, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="userId != null" &gt; #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="userName != null" &gt; #&#123;userName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null" &gt; #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.demo.entity.User" &gt; update user &lt;set &gt; &lt;if test="userName != null" &gt; user_name = #&#123;userName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; password = #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null" &gt; phone = #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/set&gt; where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.demo.entity.User" &gt; update user set user_name = #&#123;userName,jdbcType=VARCHAR&#125;, password = #&#123;password,jdbcType=VARCHAR&#125;, phone = #&#123;phone,jdbcType=VARCHAR&#125; where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/update&gt;&lt;/mapper&gt;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>generator</tag>
        <tag>逆向生成文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4j补充]]></title>
    <url>%2F2018%2F11%2F23%2F%E6%A1%86%E6%9E%B6-Log4j%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[Log4j补充 LoggerConfig LevelEvent Level和LoggerConfig Level对照表 Event Level LoggerConfig Level LoggerConfig Level LoggerConfig Level LoggerConfig Level LoggerConfig Level LoggerConfig Level LoggerConfig Level Event Level TRACE DEBUG INFO WARN ERROR FATAL OFF ALL YES YES YES YES YES YES NO TRACE YES NO NO NO NO NO NO DEBUG YES YES NO NO NO NO NO INFO YES YES YES NO NO NO NO WARN YES YES YES YES NO NO NO ERROR YES YES YES YES YES NO NO FATAL YES YES YES YES YES YES NO OFF NO NO NO NO NO NO NO 感谢大佬翻译了APILog4j输出格式控制–log4j的PatternLayout参数含义以及详细配置 官方API 没把格式化看懂，但是意外发现了一个markdown编辑神器，可以把excel表格转为Markdown表格。详见文章【利器】 参数 说明 例子 %c 列出logger名字空间的全称，如果加上{&lt;层数&gt;}表示列出从最内层算起的指定层数的名字空间 log4j配置文件参数举例 输出显示媒介 假设当前logger名字空间是”a.b.c” %c a.b.c %c{2} b.c %20c （若名字空间长度小于20，则左边用空格填充） %-20c （若名字空间长度小于20，则右边用空格填充） %.30c （若名字空间长度超过30，截去多余字符） %20.30c （若名字空间长度小于20，则左边用空格填充；若名字空间长度超过30，截去多余字符） %-20.30c （若名字空间长度小于20，则右边用空格填充；若名字空间长度超过30，截去多余字符） %C 列出调用logger的类的全名（包含包路径） 假设当前类是”org.apache.xyz.SomeClass” %C org.apache.xyz.SomeClass %C{1} SomeClass %d 显示日志记录时间，{&lt;日期格式&gt;}使用ISO8601定义的日期格式 %d{yyyy/MM/dd HH:mm:ss,SSS} 2005/10/12 22:23:30,117 %d{ABSOLUTE} 22:23:30,117 %d{DATE} 12 Oct 2005 22:23:30,117 %d{ISO8601} 2005-10-12 22:23:30,117 %F 显示调用logger的源文件名 %F MyClass.java %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数 %l MyClass.main(MyClass.java:129) %L 显示调用logger的代码行 %L 129 %m 显示输出消息 %m This is a message for debug. %M 显示调用logger的方法名 %M main %n 当前平台下的换行符 %n Windows平台下表示rn UNIX平台下表示n %p 显示该条日志的优先级 %p INFO %r 显示从程序启动时到记录该条日志时已经经过的毫秒数 %r 1215 %t 输出产生该日志事件的线程名 %t MyClass %x 按NDC（Nested Diagnostic Context，线程堆栈）顺序输出日志 假设某程序调用顺序是MyApp调用com.foo.Bar %c %x - %m%n MyApp - Call com.foo.Bar. com.foo.Bar - Log in BarMyApp - Return to MyApp. %X 按MDC（Mapped Diagnostic Context，线程映射表）输出日志。通常用于多个客户端连接同一台服务器，方便服务器区分是那个客户端访问留下来的日志。 %X{5} （记录代号为5的客户端的日志） %% 显示一个百分号 %% %]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>log4j</tag>
        <tag>补充</tag>
        <tag>log4j格式化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利器]]></title>
    <url>%2F2018%2F11%2F23%2F%E5%B7%A5%E5%85%B7-%E5%88%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[这是你的金斧子吗？这是你的银斧子吗？ 编辑器markdownExcel表格转Markdown表格官网高大上，功能很强大，未深喑其中功能但觉得安装包不小。Typora官网]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Log4j]]></title>
    <url>%2F2018%2F11%2F23%2F%E6%A1%86%E6%9E%B6-Log4j%2F</url>
    <content type="text"><![CDATA[abstract 添加依赖在pom.xml文件中添加如下依赖12345678910111213141516171819&lt;!-- spring boot start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!-- 排除自带的logback依赖 --&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- springboot-log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt; &lt;version&gt;1.3.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 编辑配置文件rootloggerrootlogger主要定义log4j支持的日志级别及输出目的地，其语法为：1log4j.rootLogger = [ level ] , appenderName, appenderName, … level 是日志记录的优先级，分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别。 appenderName指定日志信息输出到哪个地方，可同时指定多个输出目的地。 例如: 1log4j.rootLogger=info, stdout 有两个疑惑： Level 代号 FATAL 0 ERROR 3 WARN 4 INFO 6 DEBUG 7 后面Threshold有限制输出范围，如果这里设置了ERROR,Threshold设置INfO,日志会输出WARN,和INFO级别的日志信息吗？ 中间丢失的1、2、5对应什么级别，他们是被弃用了吗？我这里有酒，希望有了解的可以讲出他们的故事； appenderappender附加器主要定义日志信息输出位置，输出格式等。主要语法为： 123log4j.appender.appenderName = classInfolog4j.appender.appenderName.option1 = value1log4j.appender.appenderName.optionN = valueN 这里的appenderName与rootlogger中的appenderName对应 appender的classInfo有如下选项： org.apache.log4j.ConsoleAppender（控制台） org.apache.log4j.FileAppender（文件） org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件） org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件） org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） 例如: 1log4j.appender.stdout=org.apache.log4j.ConsoleAppender appender.option–FileFile是日志输出的目的地。 例如：1log4j.appender.stdout.File=logs/log.log appender.option–Threshold输出等级限制，包含本身及以上。 例如：12## 输出DEBUG级别以上的日志log4j.appender.stdout.Threshold=DEBUG appender.option–Append日志信息的追加方式。true意味着，默认为truefales意味着， 12345678910111213141516171819package com.qigou.b2cex.test;import com.b2bex.goods.service.EsOrderIndexManager;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.ArrayList;public class TestExcel&#123; private static final Logger logger = LoggerFactory.getLogger("BBDOG"); public static void main(String[] args) throws Exception &#123; logger.info("logger----Info"); logger.warn("logger----warn"); logger.debug("logger----debug"); logger.error("logger----error"); logger.info("-----------------------------分割线-----------------------------"); &#125;&#125; 使用默认配置，配置文件中有如下信息： 再次执行，信息如下； 配置中增加 1log4j.appender.bbdog.Append=fales 再次执行后，本想顺理成章的像其他博文一样展示只有一份信息。但学东西真的这么顺利过吗？ 实际上控制台给我报错： 1log4j:WARN Failed to set property [append] to value "fales". 然后发现呵呵呵呵！false写成了fales.修改后文件中确实只有最新的日志信息了： appender.option–Encoding日志信息的编码格式； 12## 输出DEBUG级别以上的日志log4j.appender.stdout.Encoding=UTF-8 appender.option–DatePattern在DailyRollingFileAppender中可以指定monthly(每月)、 weekly(每周)、daily(每天)、half-daily(每半天)、hourly(每小时)和minutely(每分钟)六个日志生成频度，这是通过为 DatePattern选项赋予不同的值来完成的。DatePattern选项的有效值为： ‘.’yyyy-MM,对应monthly(每月) ‘.’yyyy-ww,对应weekly(每周) ‘.’yyyy-MM-dd,对应daily(每天) ‘.’yyyy-MM-dd-a,对应half-daily(每半天) ‘.’yyyy-MM-dd-HH,对应hourly(每小时) ‘.’yyyy-MM-dd-HH-mm,对应minutely(每分钟) DatePattern中不用处理的文字要放到单引号(‘)中，如上面的(.)。如果您对此有疑问可以查阅SimpleDateFormat的文档。DailyRollingFileAppender中使用这个类来处理DatePattern。 DatePattern格式化之后的文本作为文件名字的后缀。DailyRollingFileAppender不支持格式化之后的文本作为文件名字的前缀。 修改系统时间可以看到效果，当天的文件名为bbdog.log,之前的文件名会加上频度日期 appender.option–LayoutLayout 负责格式化Appender的输出。 Log4j提供的layout有以下几种： org.apache.log4j.HTMLLayout（以HTML表格形式布局）， org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串） org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） 例如： 12log4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %5p %c&#123;1&#125;:%L - %m%n 其中ConversionPattern有如下解释 参数 含义 %m 输出代码中指定的消息 %p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL %r 输出自应用启动到输出该log信息耗费的毫秒数 %c 输出所属的类目，通常就是所在类的全名 %t 输出产生该日志事件的线程名 %n 输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n” %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss , SSS}，输出类似：2002年10月18日 22 ： 10 ： 28 ， 921 %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: 10 ) 这里只演示了DailyRollingFileAppender这种方式下的一些参数. 其他输出类型会有额外的参数，如RollingFileAppender下会有MaxFileSize和MaxBackupIndex,单个文件大小和备份数量 食用方法参考资料博客园-盖世圣猪-log4j配置详解(非常详细) CSDN-谁动了我的bug-Log4j Append属性指定是否追加内容 ConversionPattern中的格式化参数详见Log4j补充]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>Log4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web.xml]]></title>
    <url>%2F2018%2F10%2F25%2F%E8%A7%84%E8%8C%83-web-xml%2F</url>
    <content type="text"><![CDATA[什么是web.xml?在一个web项目中，往往需要一些初始化配置信息，如Welcome页面、servlet、servlet-mapping、filter、listener、启动加载级别等。web.xml文件就是用来初始化这些配置信息。但不是所有的web项目都需要web.xml文件，如果配置不是很负责，可以将他们放到Application中。 ##web.xmlweb.xml也遵循Schema配置的规则，以&lt;web-app&gt;为根标签。文件配置信息为: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; #指定Web应用的大图标和小图标 &lt;icon&gt; &lt;small-icon&gt;/images/app_small.gif&lt;/small-icon&gt; &lt;large-icon&gt;/images/app_large.gif&lt;/large-icon&gt; &lt;/icon&gt; #Web应用的名称 &lt;display-name&gt;Tomcat Example&lt;/display-name&gt; #给出于此相关的说明性文本 &lt;disciption&gt;Tomcat Example servlets and JSP pages.&lt;/disciption&gt; &lt;context-param&gt; &lt;param-name&gt;ContextParameter&lt;/para-name&gt; &lt;param-value&gt;test&lt;/param-value&gt; &lt;description&gt;It is a test parameter.&lt;/description&gt; &lt;/context-param&gt; &lt;!-- 过滤器配置 --&gt; &lt;filter&gt; &lt;filter-name&gt;setCharacterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;com.myTest.setCharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;setCharacterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 监听器 --&gt; &lt;listener&gt; &lt;listerner-class&gt;com.listener.SessionListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;servlet名称&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet类全路径&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;参数名&lt;/param-name&gt; &lt;param-value&gt;参数值&lt;/param-value&gt; &lt;/init-param&gt; &lt;run-as&gt; &lt;description&gt;匿名访问的角色&lt;/description&gt; &lt;role-name&gt;tomcat&lt;/role-name&gt; &lt;/run-as&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;servelet名称&lt;/servlet-name&gt; &lt;url-pattern&gt;映射路径&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- session超时时间（单位：分钟）--&gt; &lt;session-config&gt; &lt;session-timeout&gt;120&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;!-- mime --&gt; &lt;mime-mapping&gt; &lt;extension&gt;htm&lt;/extension&gt; &lt;mime-type&gt;text/html&lt;/mime-type&gt; &lt;/mime-mapping&gt; &lt;!-- 欢迎页 --&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 错误代码跳转页 --&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/NotFound.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.NullException&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;jsp-config&gt; &lt;taglib&gt; &lt;taglib-uri&gt;Taglib&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/tlds/MyTaglib.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;jsp-property-group&gt; &lt;description&gt;Special property group for JSP Configuration JSP example.&lt;/description&gt; &lt;display-name&gt;JSPConfiguration&lt;/display-name&gt; &lt;url-pattern&gt;/jsp/* &lt;/url-pattern&gt; &lt;el-ignored&gt;true&lt;/el-ignored&gt; &lt;page-encoding&gt;GB2312&lt;/page-encoding&gt; &lt;scripting-invalid&gt;true&lt;/scripting-invalid&gt; &lt;include-prelude&gt;/include/prelude.jspf&lt;/include-prelude&gt; &lt;include-coda&gt;/include/coda.jspf&lt;/include-coda&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>web.xml</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Red-Black Tree]]></title>
    <url>%2F2018%2F10%2F23%2F%E7%AE%97%E6%B3%95-Red-Black-Tree%2F</url>
    <content type="text"><![CDATA[你必须非常努力,才能看起来毫不费力 ———TreeMap 查找查找几乎是现在每时每刻都在用的东西，查找的速度决定了发展的速度。常用查找如： 顺序查找 二分查找 插值查找 斐波那契查找 树查找 分块查找 哈希查找 二叉树查找算法思想：为了查找的方便和快捷，先把待查找的数据生成一棵二叉排序树，利用排序树进行查找 二叉排序树有几个性值： 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树。 二叉查找树性质：对二叉查找树进行中序遍历(左根右)，即可得到有序的数列。 时间复杂度分析： 最优的情况是一个我们构建出一个完全二叉树,时间复杂度与二分查找相同,即树的高度，为O(logn)。 最坏情况是构造出一个单支树,时间复杂度为O(n); 所以，想享受O(logn)的时间复杂度的代价就是，花大功夫构造出一个便于查找的二叉树树。 2-3查找树2-3节点有下列三种可能： 节点为空节点 节点为2节点，2节点中有一个key,有两个2-3节点。左子所有key比2节点的key都小，右子所有key比2节点的key都大。 节点为3节点，3节点中有两个key,有三个2-3节点，左子所有key比3节点小的key都小，中子所有key都介于3节点两个key之间,右子所有key比3节点大的key都大。 2-3查找树特性： 在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。 时间复杂度分析： 最坏情况是所有节点都是2节点，回归二叉树，而且二叉树最优情况完全二叉树，时间复杂度为O(log2n); 最好情况是所有节点都是3节点，时间复杂度就是O(log3n),约等于O(0.631log2n)。 红黑树红黑树是2-3查找树最简单的一种实现。红黑树特性： 每个节点或者是黑色，或者是红色。根节点是黑色。 每个叶子节点（为空的）都是黑色。 红色节点的子节点都是黑色 一个节点到每个子孙节点（叶子节点），经过的黑色节点数都是相同的。 为什么说红黑树是2-3树的简单实现呢。把每个节点看作是2节点。规定红色节点与左子的链接为红色链接。红色链接连接的两个节点看做是一个3节点,就转化成了2-3查找树 TreeMap源码解析（基于jdk1.7）TreeMap是红黑树的实现,首先来看一下TreeMap的Entry 123456K key;V value;Entry&lt;K,V&gt; left = null;Entry&lt;K,V&gt; right = null;Entry&lt;K,V&gt; parent;boolean color = BLACK; 与树的Entry相比多了一个颜色标志位 color。 TreeMap的常用操作 get() put() remove() get()因为TreeMap是已经平衡过的树（因为每次对树的解构进行改动的时候都会重新调整一遍树的机构使其每次使用时都保持最佳状态，映照开头第一句话），所以get()操作就是对排序树的遍历查找，与根节点比较，从而判断下一步走向。如此循环，直至找到对应Entry，或者没有找到而结束。 get()方法调用getEntry方法实现遍历查找12345678910111213141516171819final Entry&lt;K,V&gt; getEntry(Object key) &#123; // Offload comparator-based version for sake of performance if (comparator != null) return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; &#125; return null; &#125; Offload comparator-based version for sake of performance(为了性能，卸载基于比较器的版本) put()put()方法则是先进行一遍get操作，通过K比较，将新Entry放在合适位置，如果是普通二叉树，插入操作到这里就结束了，但是这是红黑树。需要对数的结构进行负责。所以在找到合适位置，插入新Entry之后又对红黑树进行了整体调整。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; if (t == null) &#123; compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; else &#123; if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); rotateLeft(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); rotateRight(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); &#125; &#125; &#125; root.color = BLACK; &#125; remove()remove()方法同样是需要先调用getEntry找到要删除的元素，然后调用deleteEntry删除该元素，删除元素之后同样需要再次对红黑树进行解构调整。 123456789public V remove(Object key) &#123; Entry&lt;K,V&gt; p = getEntry(key); if (p == null) return null; V oldValue = p.value; deleteEntry(p); return oldValue; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; size--; // If strictly internal, copy successor's element to p and then make p // point to successor. if (p.left != null &amp;&amp; p.right != null) &#123; Entry&lt;K,V&gt; s = successor(p); p.key = s.key; p.value = s.value; p = s; &#125; // p has 2 children // Start fixup at replacement node, if it exists. Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123; // Link replacement to parent replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; // Null out links so they are OK to use by fixAfterDeletion. p.left = p.right = p.parent = null; // Fix replacement if (p.color == BLACK) fixAfterDeletion(replacement); &#125; else if (p.parent == null) &#123; // return if we are the only node. root = null; &#125; else &#123; // No children. Use self as phantom replacement and unlink. if (p.color == BLACK) fixAfterDeletion(p); if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; if (x == leftOf(parentOf(x))) &#123; Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateLeft(parentOf(x)); sib = rightOf(parentOf(x)); &#125; if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); setColor(sib, RED); rotateRight(sib); sib = rightOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(rightOf(sib), BLACK); rotateLeft(parentOf(x)); x = root; &#125; &#125; else &#123; // symmetric Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateRight(parentOf(x)); sib = leftOf(parentOf(x)); &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); setColor(sib, RED); rotateLeft(sib); sib = leftOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(leftOf(sib), BLACK); rotateRight(parentOf(x)); x = root; &#125; &#125; &#125; setColor(x, BLACK); &#125; 总结一下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>查找</tag>
        <tag>二叉树</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuffer和StringBuilder]]></title>
    <url>%2F2018%2F10%2F16%2FJava%E5%9F%BA%E7%A1%80-String-StringBuffer-StringBuilder%2F</url>
    <content type="text"><![CDATA[整理一下近期学习的String、StringBuffer和StringBuilder之间的区别 执行速度：String &lt; StringBuffer &lt; Stringbuilder String与StringBuffer和StringBuilder之间的区别 String:字符串常量 StringBuffer:字符串变量 StringBuilder:字符串变量 我们知道String是常量，常量是不可以修改的。123456789101112131415public static void main(String[] args)&#123; String str = "123"; change(str); System.out.println(str);&#125;public static void change(String s)&#123; System.out.println(s); s = s + "abc"; system.out.println(s);&#125;/*console:123123abc123*/ 可以看到change方法并没有起到效果。 调用change方法时，str和s都指向”123” 当执行s = s + &quot;abc&quot;时s指向了”123abc” ，str还是指向”123” 123String s = "123";s = s + "abc";System.out.print(s); //result : 123abc 既然是常量，那为什么这里还可以对常量进行操作呢？JVM会创建一个新的字符串常量，原来的字符串常量成为垃圾被GC回收掉。StringBuffer和StringBuilder是字符串变量，对他们的操作是在原对象上进行的操作。 所以执行速度：String &lt; StringBuffer &lt; Stringbuilder 特例12String Str = "123" + "abc" + "123abc";StringBuffer Strb = new StringBuffer("123").append("abc").append("123abc"); 上面两个字符串生成的速度并不像预期的那样，StringBuffer 快于 String。为什么？因为JVM在创建字符串常量时123String Str = "123" + "abc" + "123abc";//就等于String Str = "123abc123abc"; 所以直接被创建出来，速度很快。但是如果分步执行，就会按照JVM对常规字符串常量的操作，创建新常量，回收旧常量的方式进行操作。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>StringBuffer</tag>
        <tag>StringBuilder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven]]></title>
    <url>%2F2018%2F10%2F12%2F%E6%A1%86%E6%9E%B6-maven%2F</url>
    <content type="text"><![CDATA[abstract pom.XMLmaven坐标Maven坐标元素包括 groupId、artifactId、version、packaging、classifier.groupId：定义当前Maven项目隶属的实际项目。artifactId: 定义实际项目中的一个Maven模块。version: 定义Maven项目当前所处的版本。packaging: 定义Maven项目的打包方式。classifier: 帮助定义构件输出的一些附属构件。 传递性依赖首先我们要了解什么叫直接依赖，A依赖于B，B就是A的直接依赖。A-&gt;B，B-&gt;(C,D)。C、D都是A的传递性依赖。 我们在使用A的时候只需要指出他的直接依赖，maven会自动帮我们解析出我们所需要的间接依赖，而不会引入多余的包。 如果间接依赖引用了同一个项目，但版本不同时，maven解析有两个优先原则： 深度策略。A-&gt;B-&gt;C(1.0) A-&gt;C(2.0)。此时导入C(2.0) FCFS策略。A-&gt;B-&gt;C(1.0) A-&gt;B-&gt;C(2.0)。此时导入C(1.0) 排除依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;3.2.7&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;apache-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 引入了rocketmq,但是不想引入rocketmq里面的apache-lang就可以用exclusions元素进行排除。 排除的时候只需要定位groupId和artifactId就可以确定这个依赖。 setting.XMLlocalRepository本地仓库路径默认值为:$ {user.home} /.m2 / repository1&lt;localRepository&gt;D:/Program Files/Apache/maven-repository&lt;/localRepository&gt; interactiveModeMaven是否应该尝试与用户进行交互以进行输入。默认为:true usePluginRegistryMaven是否单独使用plugin-registry.xml文件来管理插件版本默认值为:false offline设置maven是否应该在全离线模式下运行。默认值为:false proxiesproxies表示maven的代理123456789101112&lt;proxies&gt; &lt;proxy&gt; &lt;id&gt;optional&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;username&gt;proxyuser&lt;/username&gt; &lt;password&gt;proxypass&lt;/password&gt; &lt;host&gt;proxy.host.net&lt;/host&gt; &lt;port&gt;80&lt;/port&gt; &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt; &lt;/proxy&gt;&lt;/proxies&gt; proxies下可以设置多个proxy，使用ID进行唯一标识区分。 id: 每个代理的唯一标识. active: 代理的激活状态，默认值为:true。设置多个代理时，使用第一个active为true的代理。 protocol: 代理使用的协议。默认值为:http username: 代理需要认证时的用户名。 password: 代理需要认证时的密码。 host: 主机名 port: 端口号,默认值为:8080 nonProxyHosts: 表示指定哪些主机名不需要代理，可以用”|” 分隔多个主机名，也支持通配符”*“; server用于连接远程仓库时的安全认证123456789101112&lt;servers&gt; &lt;server&gt; &lt;id&gt;nexus-releases&lt;/id&gt; &lt;username&gt;deployment&lt;/username&gt; &lt;password&gt;deployment&lt;/password&gt; &lt;privateKey&gt;$&#123;usr.home&#125;/.ssh/id_dsa&lt;/privateKey&gt; &lt;passphrase&gt;some_passphrase&lt;/passphrase&gt; &lt;filePermissions&gt;664&lt;/filePermissions&gt; &lt;directoryPermissions&gt;775&lt;/directoryPermissions&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/server&gt;&lt;/serves&gt; id: id是最关键的，这个id必须与需要认证的repository元素的id完全一致才行，换句话说，正式这个id将认证信息和仓库配置联系在了一起。 username: 用户名 password: 密码 privateKey: 鉴权时使用的私钥位置 passphrase: 鉴权时使用的私钥密码。 filePermissions: 文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。 directoryPermissions: 目录被创建时的权限 configuration: 传输层额外的配置项 mirrors仓库的镜像12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;all repository mirror&lt;/name&gt; &lt;url&gt;http://172.16.21.3:8081/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; id,name,url与仓库的配置相同 id: 仓库的唯一标识。 name: 仓库名 url: 仓库的地址.http://maven.net.cn/content/groups/public/ 是 中央仓库 http://repo1.maven.org/maven2/ 在中国的镜像。 mirrorOf：*表示任何对中央仓库的请求都会被转到镜像仓库中。profile个性配置文件，可以通过不同的方式激活。激活条件全部满足时激活该配置文件 1234567891011121314151617181920&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;activation&gt; ··· &lt;/activation&gt; &lt;repositories&gt; &lt;repository&gt; ··· &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; ··· &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; id: 配置文件的唯一标识 activation: 激活方式 repositories: 依赖仓库 pluginRepositories: 插件仓库 activation123456789101112131415161718&lt;activation&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;jdk&gt;1.6&lt;/jdk&gt; &lt;os&gt; &lt;name&gt;Windows 7&lt;/name&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;property&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;file&gt; &lt;exists&gt;$&#123;basedir&#125;/file2.properties&lt;/exists&gt; &lt;missing&gt;$&#123;basedir&#125;/file1.properties&lt;/missing&gt; &lt;/file&gt;&lt;/activation&gt; activeByDefault: 当设置为true时，没有其他profile激活时，自动激活。 jdk: 当JDK版本满足时激活，可以用开闭区间表示一个JDK满足的范围。 os: 当操作系统满足时激活 name: 操作系统 family: 操作系统类型 arch: 操作系统位数 version: 操作系统版本 property: 键值对的形式,当只存在name时。hello属性存在,即可激活。当name，value都存在时，hello属性存在，并且hello属性的value为world时可以激活。 name: hello value: world file: 表示当文件存在或不存在的时候激活 exists: 该路径上的文件存在时激活 missing: 该路径上的文件不存在时激活 repository123456789101112131415161718&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;codehausSnapshots&lt;/id&gt; &lt;name&gt;Codehaus Snapshots&lt;/name&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;never&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;fail&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;url&gt;http://snapshots.maven.codehaus.org/maven2&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt;&lt;/repositories&gt; repositories中可以有多个repository,使用ID进行唯一标识区分。 id: 每个中央仓库的唯一标识。Maven自带的中央仓库使用的id为central，如果其他仓库声明也用该id，就会覆盖中央仓库的配置。 name: 仓库名 url: 中央仓库的地址。 releases: 表示开启仓库的发布版本下载支持。 enabled: 启用状态。默认值为:true。 updatePolicy: 更新时间，可选值有(always、daily、interval:minutes和never) always: 始终 daily: 每天 interval:minutes: 指定时间间隔(单位为分钟) never: 从不 checksumPolicy: 当Maven在部署项目到仓库的时候会连同校验文件一起提交，checksumPolicy表示当这个校验文件缺失或不正确的时候该如何处理，可选项有ignore、fail和warn。 ignore: 忽略 fail: 失败 warn: 警告 snapshots: 表示关闭仓库的快照版本下载支持。参数与releases类似 pluginRepository插件仓库与依赖仓库配置类似12345678910111213&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;http://central&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt; activeProfiles手动激活的构建配置文件列表，按照应用顺序指定。1234&lt;activeProfiles&gt; &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt; &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;&lt;/activeProfiles&gt; 上述配置表示激活所有。 pluginGroups插件组123&lt;pluginGroups&gt; &lt;pluginGroup&gt;org.mortbay.jetty&lt;/pluginGroup&gt;&lt;/pluginGroups&gt; 添加了上面的插件后就可以使用 1mvn jetty:run]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memchahed介绍]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%A1%86%E6%9E%B6-memchahed%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[abstract 我们先抛出几个问题。 什么是缓存？为什么要有缓存？有哪些缓存技术以及他们的优缺点？]]></content>
      <categories>
        <category>框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[javaScript]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%89%8D%E7%AB%AF-javaScript%2F</url>
    <content type="text"><![CDATA[abstract 字符串操作substring截取字符串(“有始无终”) var s = &quot;abcd&quot;; s.substring(1,3); -&gt; &quot;bc&quot; $.trim()$.trim() 函数用于去除字符串两端的空白字符。 var s = &quot; 123 123 456 &quot; $.trim(s); -&gt; &quot;123 123 456&quot; AJAX一、$.ajax()该方法是 jQuery 底层 AJAX 实现。 1、async类型：Boolean 默认值: true。 默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。两条并列AJAX要区分先后顺序的话应采取同步 2、cache类型：Boolean 默认值: true。 dataType 为 script 和 jsonp 时默认为 false。设置为 false 将不缓存此页面。 3、contentType类型：String 默认值: “application/x-www-form-urlencoded”。 请求发送信息至服务器时内容编码类型。默认值适合大多数情况。如果你明确地传递了一个content-type给 $.ajax() 那么它必定会以设定类型发送给服务器（即使没有数据要发送）。 4、success类型：Function 请求成功后的回调函数。 参数：由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串。 这是一个 Ajax 事件。 5、error类型：Function 默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。 有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。 如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是 “timeout”, “error”, “notmodified” 和 “parsererror”。 这是一个 Ajax 事件。 6、type类型：String 默认值: (“GET”)。 请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。 7、url类型：String 默认值: 当前页地址。 发送请求的地址。 8、dataType类型：String 预期接收服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断. “xml”: 返回 XML 文档，可用 jQuery 处理。 “html”: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。 “script”: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 “cache” 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载） “json”: 返回 JSON 数据 。 “jsonp”: JSONP 格式。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 “text”: 返回纯文本字符串 9、data类型：String 发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[“bar1”, “bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。 $.ajax({ type: &quot;POST&quot;, async: true, cache: true, url: &quot;ajax.php&quot;, dataType: &quot;json&quot;, data: {&quot;username&quot;: &quot;bbdog&quot;,&quot;password&quot;: 123456}, contentType: &quot;&quot;, success: function(msg) { console.log(msg) }, error: function() { console.log(&quot;error&quot;) } }) 二、$.post()语法jQuery.post(url,data,success(data, textStatus, jqXHR),dataType) url必需。规定把请求发送到哪个 URL。 data可选。映射或字符串值。规定连同请求发送到服务器的数据。 success(data, textStatus, jqXHR)可选。请求成功时执行的回调函数。 dataType可选。规定预期的服务器响应的数据类型。 默认执行智能判断（xml、json、script 或 html）。 三、$.get()$(selector).get(url,data,success(response,status,xhr),dataType) 参数于post()方法类似 选择器.val().html().text() 操作DOMremove()和empty()删除元素/内容 如需删除元素和内容，一般可使用以下两个 jQuery 方法： remove() - 删除被选元素（及其子元素） empty() - 从被选元素中删除子元素 append()和appendTo$(selector).append(content) $(selector).append(function(index,html)) $(content).appendTo(selector) Tips:append() 和 appendTo() 方法执行的任务相同。不同之处在于：内容和选择器的位置，以及 append() 能够使用函数来附加内容。 .val().html().text() text()//返回文本内容 $(selector).text(); //设置文本内容 $(selector).text(content); //使用函数设置内容 $(selector).text(function(index,oldcontent)) $(selector).attr({attribute:value, attribute:value ...}) class//添加样式 $(selector).addClass(class) //同时添加多个中间用空格隔开 //移除样式 $(selector).removeClass(class) 属性attr //返回属性值 $(selector).attr(attribute) //设置属性值 $(selector).attr(attribute,value) //移除属性值 $(selector).removeAttr(attribute) 可以操作标签的属性和样式的属性；css //返回属性值 $(&quot;p&quot;).css(&quot;background-color&quot;); //设置属性值 $(&quot;p&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;); 隐藏与显示查看显示与隐藏 $(&apos;div:visible&apos;); // 所有可见的div $(&apos;div:hidden&apos;); // 所有隐藏的div 1.hide()和show() //隐藏 $(selector).hide(speed,callback); //显示 $(selector).show(speed,callback); 可选的 speed 参数规定隐藏/显示的速度，可以取以下值：&quot;slow&quot;、&quot;fast&quot; 或毫秒。 可选的 callback 参数是隐藏或显示完成后所执行的函数名称。 2.toggle() //显示被隐藏的元素，并隐藏已显示的元素： $(selector).toggle(speed,callback); 3.css(‘display’,*) $(&quot;#id&quot;).css(&apos;display&apos;,&apos;none&apos;);//隐藏 $(&quot;#id&quot;).css(&apos;display&apos;,&apos;block&apos;);//显示 或者 $(&quot;#id&quot;)[0].style.display=&apos;none&apos;; 4.css(‘visibility’,*) $(&quot;#id&quot;).css(&apos;visibility&apos;,&apos;hidden&apos;);//元素隐藏 $(&quot;#id&quot;).css(&apos;visibility&apos;,&apos;visible&apos;);//元素显示 display:none与visible:hidden的区别 visible保留&apos;物理空间&apos;,display不保留&apos;物理空间&apos; 数据类型转换typeof()typeof()可以用来检测给定变量的数据类型,它将返回一个字符串，表示表达式的类型，而表达式的类型只有六种可能： number string boolean object function undefined 转为数字类型转为Int var iNum1 = parseInt(“1234blue”); -&gt; 1234 var iNum2 = parseInt(“oxA”); -&gt; 10 var iNum3 = parseInt(“22.5″); -&gt; 22 var iNum4 = parseInt(“blue”); -&gt; NaN 基模式转为Int var iNum1 = parseInt(“AF”,16); -&gt; 175 var iNum2 = parseInt(“10″,2); -&gt; 2 var iNum3 = parseInt(“10″,8); -&gt; 8 var iNum4 = parseInt(“10″,10); -&gt; 10 如果以0开头最好使用十进制基模式 var iNum1 = parseInt(“010″); -&gt; 8 转为Float var fNum1 = parseFloat(“1234blue”); -&gt; 1234.0 var fNum2 = parseFloat(“0xA”); -&gt; NaN var fNum3 = parseFloat(“.22.5″); -&gt; 0.22 var fNum5 = parseFloat(“0908″); -&gt; NaN var fNum6 = parseFloat(“blue”); -&gt; NaN 转为字符串类型使用toString()方法,常用源数据有Boolean、number、String 1.Boolean var b = true; b.toString(); -&gt; &quot;true&quot; 2.number[默认模式] var num1 = 10.00; num1.toString(); -&gt; &quot;10&quot; 3.number[基（进制基数）模式] var iNum = 10; alert(iNum.toString(2)); -&gt; “1010″ alert(iNum.toString(8)); -&gt; “12″ alert(iNum.toString(16)); -&gt; “A” replace()String.replace(regexp/substr,replacement); var s = &quot;abcd&quot; s = s.replace(&quot;a&quot;,&quot;z&quot;); -&gt; &quot;zbcd&quot; s = s.replace(/c/,&quot;z&quot;); -&gt; &quot;zbzd&quot; s = s.replace(/z/g,&quot;a&quot;); -&gt; &quot;abad&quot; s = s.replace() 将json对象序列化为json字符串contentType: ‘application/json’JSON.stringify(JSONObject) 服务器端可以用JSON.parse将json串还原成JSONObject 数字计算“四舍六入五成双”的toFixed 当有效位后一位，≤4 时舍去,≥6时进1；当等于5时，先判断5后是否还有数，有则进；无数时再判断5数的奇偶性，前为奇数则进1，否则舍去。不同浏览器执行不同ES标准，计算时可能有所不同（尤其IE浏览器） toFixed()返回数字形式的字符串,可参与运算可以用toFixed补全小数点数。 取整Math.round()可先*100 再/100 用于四舍五入。 和传统四舍五入最接近，当有效位后一位，≤4 时舍去,≥6时进1，当等于5时，向正无穷方向取整 待认领window.confirm .dialog .parents $(this) .siblings .not .eq .each .prev .live .is .before .match 数据为空的几种方式null “” undefined正则]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA]]></title>
    <url>%2F2018%2F08%2F02%2F%E5%B7%A5%E5%85%B7-IntelliJ-IDEA%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[FreeMarker]]></title>
    <url>%2F2018%2F08%2F02%2F%E5%89%8D%E7%AB%AF-FreeMarker%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SSM]]></title>
    <url>%2F2018%2F08%2F02%2F%E6%A1%86%E6%9E%B6-SSM%2F</url>
    <content type="text"><![CDATA[abstract 主标签次级标签CRUD标签### 通用参数id 唯一标识parameterType 出入参数类型 flushCachestatementTypetimeout resultTyperesultMapuseCache useGeneratedKeyskeyProperty其他参数：]]></content>
      <categories>
        <category>框架</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL]]></title>
    <url>%2F2018%2F08%2F02%2F%E6%95%B0%E6%8D%AE%E5%BA%93-SQL%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML]]></title>
    <url>%2F2018%2F08%2F02%2F%E5%89%8D%E7%AB%AF-HTML%2F</url>
    <content type="text"><![CDATA[abstract]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于如何学习方法的总结]]></title>
    <url>%2F2018%2F08%2F02%2F%E6%8A%80%E5%B7%A7-%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[记一些学习技术的方法，用高效的方法去学习新的东西，花点时间去学习 学习的技巧收益会比“努力学习”更高，就像提升加速度比提升速度走的更远。 给一个时间限度首先需要先初步了解要学习的技术，对需要掌握的点有个初步认识。再根据自己可支配的学习时间估算出一个比较合理的截止时间。 动手敲敲怎么防止不学完就忘好记性不如烂笔头，可以搭建一个自己的博客，将自己的收获写在里面。不在乎有多少人去看，重在在于这个整理的过程。费曼学习法中指出，当你能熟练的把一个东西向别人讲述的时候，你也就学会了这个东西。 不放过细小的部分，只要是写出来的东西都要对他负责，不用整理的很细致，把涉及的源码都剖析一遍。重在整个文章能围绕一条中心线走下去。看起来很有层次性。 当你把写博客成为一种习惯，时间长了看看之前写的博客对自己也是一种收获。]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
        <tag>高效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 勿忘启蒙之师 Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
